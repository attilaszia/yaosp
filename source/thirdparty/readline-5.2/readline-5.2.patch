diff -Nru readline-5.2-orig/bind.c readline-5.2/bind.c
--- readline-5.2-orig/bind.c	2006-07-27 15:44:10.000000000 +0200
+++ readline-5.2/bind.c	2009-02-19 08:54:41.000000000 +0100
@@ -341,6 +341,7 @@
   register int i;
   KEYMAP_ENTRY k;
 
+  k.type = 0;
   k.function = 0;
 
   /* If no keys to bind to, exit right away. */
@@ -442,7 +443,7 @@
 {
   register int i, c, l, temp;
 
-  for (i = l = 0; c = seq[i]; i++)
+  for (i = l = 0; (c = seq[i]); i++)
     {
       if (c == '\\')
 	{
@@ -1185,7 +1186,7 @@
     {
       int passc = 0;
 
-      for (i = 1; c = string[i]; i++)
+      for (i = 1; (c = string[i]); i++)
 	{
 	  if (passc)
 	    {
@@ -1276,7 +1277,7 @@
       int delimiter, passc;
 
       delimiter = string[i++];
-      for (passc = 0; c = string[i]; i++)
+      for (passc = 0; (c = string[i]); i++)
 	{
 	  if (passc)
 	    {
@@ -2048,7 +2049,7 @@
 
   fprintf (rl_outstream, "\n");
 
-  for (i = 0; name = names[i]; i++)
+  for (i = 0; (name = names[i]); i++)
     {
       rl_command_func_t *function;
       char **invokers;
diff -Nru readline-5.2-orig/complete.c readline-5.2/complete.c
--- readline-5.2-orig/complete.c	2006-07-28 17:35:49.000000000 +0200
+++ readline-5.2/complete.c	2009-02-19 15:53:05.000000000 +0100
@@ -428,7 +428,7 @@
 	return (1);
       if (c == 'n' || c == 'N' || c == RUBOUT)
 	return (0);
-      if (c == ABORT_CHAR)
+      if (c == ABORT_CHAR || c < 0)
 	_rl_abort_internal ();
       if (for_pager && (c == NEWLINE || c == RETURN))
 	return (2);
@@ -883,7 +883,7 @@
       /* We didn't find an unclosed quoted substring upon which to do
          completion, so use the word break characters to find the
          substring on which to complete. */
-      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))
+      while ((rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY)))
 	{
 	  scan = rl_line_buffer[rl_point];
 
@@ -1802,7 +1802,7 @@
   match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
   match_list[1] = (char *)NULL;
 
-  while (string = (*entry_function) (text, matches))
+  while ((string = (*entry_function) (text, matches)))
     {
       if (matches + 1 == match_list_size)
 	match_list = (char **)xrealloc
@@ -1853,7 +1853,7 @@
     }
 
 #if defined (HAVE_GETPWENT)
-  while (entry = getpwent ())
+  while ((entry = getpwent ()))
     {
       /* Null usernames should result in all users as possible completions. */
       if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
diff -Nru readline-5.2-orig/config.h readline-5.2/config.h
--- readline-5.2-orig/config.h	1970-01-01 01:00:00.000000000 +0100
+++ readline-5.2/config.h	2009-02-19 15:59:56.000000000 +0100
@@ -0,0 +1,269 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Maintained by hand. */
+
+/* Define NO_MULTIBYTE_SUPPORT to not compile in support for multibyte
+   characters, even if the OS supports them. */
+#define NO_MULTIBYTE_SUPPORT
+
+/* Define if on MINIX.  */
+/* #undef _MINIX */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+#define VOID_SIGHANDLER 1
+
+/* Characteristics of the compiler. */
+/* #undef const */
+
+/* #undef size_t */
+
+/* #undef ssize_t */
+
+#define PROTOTYPES 1
+
+/* #undef __CHAR_UNSIGNED__ */
+
+/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define if you have the fcntl function. */
+#define HAVE_FCNTL 1
+
+/* Define if you have the getpwent function. */
+#define HAVE_GETPWENT 1
+
+/* Define if you have the getpwnam function. */
+/* #undef HAVE_GETPWNAM */
+
+/* Define if you have the getpwuid function. */
+/* #undef HAVE_GETPWUID */
+
+/* Define if you have the isascii function. */
+#define HAVE_ISASCII 1
+
+/* Define if you have the iswctype function.  */
+/* #undef HAVE_ISWCTYPE */
+
+/* Define if you have the iswlower function.  */
+/* #undef HAVE_ISWLOWER */
+
+/* Define if you have the iswupper function.  */
+/* #undef HAVE_ISWUPPER */
+
+/* Define if you have the isxdigit function. */
+#define HAVE_ISXDIGIT 1
+
+/* Define if you have the kill function. */
+#define HAVE_KILL 1
+
+/* Define if you have the lstat function. */
+#define HAVE_LSTAT 1
+
+/* Define if you have the mbrlen function. */
+#define HAVE_MBRLEN 1
+
+/* Define if you have the mbrtowc function. */
+#define HAVE_MBRTOWC 1
+
+/* Define if you have the mbsrtowcs function. */
+#define HAVE_MBSRTOWCS 1
+
+/* Define if you have the memmove function. */
+#define HAVE_MEMMOVE 1
+
+/* Define if you have the putenv function.  */
+/* #undef HAVE_PUTENV */
+
+/* Define if you have the select function.  */
+#define HAVE_SELECT 1
+
+/* Define if you have the setenv function.  */
+/* #undef HAVE_SETENV */
+
+/* Define if you have the setlocale function. */
+/* #undef HAVE_SETLOCALE */
+
+/* Define if you have the strcasecmp function.  */
+#define HAVE_STRCASECMP 1
+
+/* Define if you have the strcoll function.  */
+/* #undef HAVE_STRCOLL */
+
+/* #undef STRCOLL_BROKEN */
+
+/* Define if you have the strpbrk function.  */
+#define HAVE_STRPBRK 1
+
+/* Define if you have the tcgetattr function.  */
+#define HAVE_TCGETATTR 1
+
+/* Define if you have the towlower function.  */
+#define HAVE_TOWLOWER 1
+
+/* Define if you have the towupper function.  */
+#define HAVE_TOWUPPER 1
+
+/* Define if you have the vsnprintf function.  */
+#define HAVE_VSNPRINTF 1
+
+/* Define if you have the wcrtomb function.  */
+#define HAVE_WCRTOMB 1
+
+/* Define if you have the wcscoll function.  */
+#define HAVE_WCSCOLL 1
+
+/* Define if you have the wctype function.  */
+#define HAVE_WCTYPE 1
+
+/* Define if you have the wcwidth function.  */
+#define HAVE_WCWIDTH 1
+
+#define STDC_HEADERS 1
+
+/* Define if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <langinfo.h> header file.  */
+#define HAVE_LANGINFO_H 1
+
+/* Define if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have the <locale.h> header file.  */
+#define HAVE_LOCALE_H 1
+
+/* Define if you have the <memory.h> header file.  */
+#define HAVE_MEMORY_H 1
+
+/* Define if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the <pwd.h> header file.  */
+#define HAVE_PWD_H 1
+
+/* Define if you have the <stdarg.h> header file.  */
+#define HAVE_STDARG_H 1
+
+/* Define if you have the <stdlib.h> header file.  */
+#define HAVE_STDLIB_H 1
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <strings.h> header file.  */
+/* #undef HAVE_STRINGS_H */
+
+/* Define if you have the <sys/dir.h> header file.  */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if you have the <sys/file.h> header file.  */
+/* #undef HAVE_SYS_FILE_H */
+
+/* Define if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/pte.h> header file.  */
+/* #undef HAVE_SYS_PTE_H */
+
+/* Define if you have the <sys/ptem.h> header file.  */
+/* #undef HAVE_SYS_PTEM_H */
+
+/* Define if you have the <sys/select.h> header file.  */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define if you have the <sys/stream.h> header file.  */
+/* #undef HAVE_SYS_STREAM_H */
+
+/* Define if you have the <termcap.h> header file.  */
+#define HAVE_TERMCAP_H 1
+
+/* Define if you have the <termio.h> header file.  */
+/* #undef HAVE_TERMIO_H */
+
+/* Define if you have the <termios.h> header file.  */
+#define HAVE_TERMIOS_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the <varargs.h> header file.  */
+/* #undef HAVE_VARARGS_H */
+
+/* Define if you have the <wchar.h> header file.  */
+/* #undef HAVE_WCHAR_H */
+
+/* Define if you have the <wctype.h> header file.  */
+/* #undef HAVE_WCTYPE_H */
+
+#define HAVE_MBSTATE_T 1
+
+/* Define if you have wchar_t in <wctype.h>. */
+#define HAVE_WCHAR_T 1
+
+/* Define if you have wctype_t in <wctype.h>. */
+#define HAVE_WCTYPE_T 1
+
+/* Define if you have wint_t in <wctype.h>. */
+#define HAVE_WINT_T 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+#define HAVE_LANGINFO_CODESET 1
+
+/* Definitions pulled in from aclocal.m4. */
+#define VOID_SIGHANDLER 1
+
+#define GWINSZ_IN_SYS_IOCTL 1
+
+#define STRUCT_WINSIZE_IN_SYS_IOCTL 1
+
+/* #undef STRUCT_WINSIZE_IN_TERMIOS */
+
+/* #undef TIOCSTAT_IN_SYS_IOCTL */
+
+#define FIONREAD_IN_SYS_IOCTL 1
+
+/* #undef SPEED_T_IN_SYS_TYPES */
+
+#define HAVE_GETPW_DECLS 1
+
+/* #undef STRUCT_DIRENT_HAS_D_INO */
+
+/* #undef STRUCT_DIRENT_HAS_D_FILENO */
+
+/* #undef HAVE_BSD_SIGNALS */
+
+/* #undef HAVE_POSIX_SIGNALS */
+
+/* #undef HAVE_USG_SIGHOLD */
+
+/* #undef MUST_REINSTALL_SIGHANDLERS */
+
+/* #undef HAVE_POSIX_SIGSETJMP */
+
+#define CTYPE_NON_ASCII 1
+
+/* modify settings or make new ones based on what autoconf tells us. */
+
+/* Ultrix botches type-ahead when switching from canonical to
+   non-canonical mode, at least through version 4.3 */
+#if !defined (HAVE_TERMIOS_H) || !defined (HAVE_TCGETATTR) || defined (ultrix)
+#  define TERMIOS_MISSING
+#endif
+
+#if defined (STRCOLL_BROKEN)
+#  define HAVE_STRCOLL 1
+#endif
+
+#if defined (__STDC__) && defined (HAVE_STDARG_H)
+#  define PREFER_STDARG
+#  define USE_VARARGS
+#else
+#  if defined (HAVE_VARARGS_H)
+#    define PREFER_VARARGS
+#    define USE_VARARGS
+#  endif
+#endif
diff -Nru readline-5.2-orig/display.c readline-5.2/display.c
--- readline-5.2-orig/display.c	2006-09-14 20:20:12.000000000 +0200
+++ readline-5.2/display.c	2009-02-19 15:57:21.000000000 +0100
@@ -229,7 +229,10 @@
      int *lp, *lip, *niflp, *vlp;
 {
   char *r, *ret, *p, *igstart;
-  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;
+#if defined (HANDLE_MULTIBYTE)
+  int ind, pind;
+#endif
+  int l, rl, last, ignoring, ninvis, invfl, invflset, physchars;
 
   /* Short-circuit if we can. */
   if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
@@ -391,14 +394,14 @@
       t = ++p;
       local_prompt = expand_prompt (p, &prompt_visible_length,
 				       &prompt_last_invisible,
-				       (int *)NULL,
+				       &prompt_invis_chars_first_line,
 				       &prompt_physical_chars);
       c = *t; *t = '\0';
       /* The portion of the prompt string up to and including the
 	 final newline is now null-terminated. */
       local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
 						   (int *)NULL,
-						   &prompt_invis_chars_first_line,
+						   (int *)NULL,
 						   (int *)NULL);
       *t = c;
       local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
@@ -459,9 +462,10 @@
   register int in, out, c, linenum, cursor_linenum;
   register char *line;
   int inv_botlin, lb_botlin, lb_linenum, o_cpos;
-  int newlines, lpos, temp, modmark, n0, num;
+  int newlines, lpos, temp, modmark;
   char *prompt_this_line;
 #if defined (HANDLE_MULTIBYTE)
+  int n0, num;
   wchar_t wc;
   size_t wc_bytes;
   int wc_width;
@@ -561,14 +565,26 @@
       wrap_offset = prompt_invis_chars_first_line = 0;
     }
 
+#if defined (HANDLE_MULTIBYTE)
 #define CHECK_INV_LBREAKS() \
       do { \
 	if (newlines >= (inv_lbsize - 2)) \
 	  { \
 	    inv_lbsize *= 2; \
 	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
+	    _rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
 	  } \
       } while (0)
+#else
+#define CHECK_INV_LBREAKS() \
+      do { \
+	if (newlines >= (inv_lbsize - 2)) \
+	  { \
+	    inv_lbsize *= 2; \
+	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
+	  } \
+      } while (0)
+#endif /* HANDLE_MULTIBYTE */
 
 #if defined (HANDLE_MULTIBYTE)	  
 #define CHECK_LPOS() \
@@ -626,7 +642,6 @@
      contents of the command line? */
   while (lpos >= _rl_screenwidth)
     {
-      int z;
       /* fix from Darin Johnson <darin@acuson.com> for prompt string with
          invisible characters that is longer than the screen width.  The
          prompt_invis_chars_first_line variable could be made into an array
@@ -635,6 +650,8 @@
          prompts that exceed two physical lines?
          Additional logic fix from Edward Catmur <ed@catmur.co.uk> */
 #if defined (HANDLE_MULTIBYTE)
+      int z;
+
       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
 	{
 	  n0 = num;
@@ -898,6 +915,10 @@
 	     second and subsequent lines start at inv_lbreaks[N], offset by
 	     OFFSET (which has already been calculated above).  */
 
+#define INVIS_FIRST()	(prompt_physical_chars > _rl_screenwidth ? prompt_invis_chars_first_line : wrap_offset)
+#define WRAP_OFFSET(line, offset)  ((line == 0) \
+					? (offset ? INVIS_FIRST() : 0) \
+					: ((line == prompt_last_screen_line) ? wrap_offset-prompt_invis_chars_first_line : 0))
 #define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)
 #define VIS_LLEN(l)	((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
 #define INV_LLEN(l)	(inv_lbreaks[l+1] - inv_lbreaks[l])
@@ -932,7 +953,13 @@
 		  _rl_last_c_pos != o_cpos &&
 		  _rl_last_c_pos > wrap_offset &&
 		  o_cpos < prompt_last_invisible)
-		_rl_last_c_pos -= wrap_offset;
+		_rl_last_c_pos -= prompt_invis_chars_first_line;	/* XXX - was wrap_offset */
+	      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&
+			(MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
+			cpos_adjusted == 0 &&
+			_rl_last_c_pos != o_cpos &&
+			_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))
+		_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);
 		  
 	      /* If this is the line with the prompt, we might need to
 		 compensate for invisible characters in the new line. Do
@@ -1036,7 +1063,7 @@
 		tx = _rl_col_width (&visible_line[pos], 0, nleft) - visible_wrap_offset;
 	      else
 		tx = nleft;
-	      if (_rl_last_c_pos > tx)
+	      if (tx >= 0 && _rl_last_c_pos > tx)
 		{
 	          _rl_backspace (_rl_last_c_pos - tx);	/* XXX */
 	          _rl_last_c_pos = tx;
@@ -1192,7 +1219,7 @@
      int current_line, omax, nmax, inv_botlin;
 {
   register char *ofd, *ols, *oe, *nfd, *nls, *ne;
-  int temp, lendiff, wsatend, od, nd;
+  int temp, lendiff, wsatend, od, nd, twidth, o_cpos;
   int current_invis_chars;
   int col_lendiff, col_temp;
 #if defined (HANDLE_MULTIBYTE)
@@ -1208,7 +1235,7 @@
   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     temp = _rl_last_c_pos;
   else
-    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
+    temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);
   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
 	&& _rl_last_v_pos == current_line - 1)
     {
@@ -1453,6 +1480,8 @@
 	_rl_last_c_pos = lendiff;
     }
 
+  o_cpos = _rl_last_c_pos;
+
   /* When this function returns, _rl_last_c_pos is correct, and an absolute
      cursor postion in multibyte mode, but a buffer index when not in a
      multibyte locale. */
@@ -1462,7 +1491,9 @@
   /* We need to indicate that the cursor position is correct in the presence of
      invisible characters in the prompt string.  Let's see if setting this when
      we make sure we're at the end of the drawn prompt string works. */
-  if (current_line == 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0 && _rl_last_c_pos == prompt_physical_chars)
+  if (current_line == 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0 && 
+      (_rl_last_c_pos > 0 || o_cpos > 0) &&
+      _rl_last_c_pos == prompt_physical_chars)
     cpos_adjusted = 1;
 #endif
 #endif
@@ -1506,11 +1537,31 @@
     {
       /* Non-zero if we're increasing the number of lines. */
       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
+      /* If col_lendiff is > 0, implying that the new string takes up more
+	 screen real estate than the old, but lendiff is < 0, meaning that it
+	 takes fewer bytes, we need to just output the characters starting
+	 from the first difference.  These will overwrite what is on the
+	 display, so there's no reason to do a smart update.  This can really
+	 only happen in a multibyte environment. */
+      if (lendiff < 0)
+	{
+	  _rl_output_some_chars (nfd, temp);
+	  _rl_last_c_pos += _rl_col_width (nfd, 0, temp);
+	  /* If nfd begins before any invisible characters in the prompt,
+	     adjust _rl_last_c_pos to account for wrap_offset and set
+	     cpos_adjusted to let the caller know. */
+	  if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
+	    {
+	      _rl_last_c_pos -= wrap_offset;
+	      cpos_adjusted = 1;
+	    }
+	  return;
+	}
       /* Sometimes it is cheaper to print the characters rather than
 	 use the terminal's capabilities.  If we're growing the number
 	 of lines, make sure we actually cause the new line to wrap
 	 around on auto-wrapping terminals. */
-      if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
+      else if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
 	{
 	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
 	     _rl_horizontal_scroll_mode == 1, inserting the characters with
@@ -1533,11 +1584,16 @@
 	    }
 	  else
 	    {
-	      /* We have horizontal scrolling and we are not inserting at
-		 the end.  We have invisible characters in this line.  This
-		 is a dumb update. */
 	      _rl_output_some_chars (nfd, temp);
 	      _rl_last_c_pos += col_temp;
+	      /* If nfd begins before any invisible characters in the prompt,
+		 adjust _rl_last_c_pos to account for wrap_offset and set
+		 cpos_adjusted to let the caller know. */
+	      if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
+		{
+		  _rl_last_c_pos -= wrap_offset;
+		  cpos_adjusted = 1;
+		}
 	      return;
 	    }
 	  /* Copy (new) chars to screen from first diff to last match. */
@@ -1545,15 +1601,15 @@
 	  if ((temp - lendiff) > 0)
 	    {
 	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
-#if 1
 	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
 		reported against bash-3.0-alpha by Andreas Schwab involving
 		multibyte characters and prompt strings with invisible
 		characters, but was previously disabled. */
-	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
-#else
-	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
-#endif
+	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
+		twidth = _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
+	      else
+		twidth = temp - lendiff;
+	      _rl_last_c_pos += twidth;
 	    }
 	}
       else
@@ -1586,8 +1642,22 @@
 	  temp = nls - nfd;
 	  if (temp > 0)
 	    {
+	      /* If nfd begins at the prompt, or before the invisible
+		 characters in the prompt, we need to adjust _rl_last_c_pos
+		 in a multibyte locale to account for the wrap offset and
+		 set cpos_adjusted accordingly. */
 	      _rl_output_some_chars (nfd, temp);
-	      _rl_last_c_pos += _rl_col_width (nfd, 0, temp);;
+	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
+		{
+                  _rl_last_c_pos += _rl_col_width (nfd, 0, temp);
+                  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
+		    {
+		      _rl_last_c_pos -= wrap_offset;
+		      cpos_adjusted = 1;
+		    }
+		}
+              else
+                _rl_last_c_pos += temp;
 	    }
 	}
       /* Otherwise, print over the existing material. */
@@ -1595,8 +1665,20 @@
 	{
 	  if (temp > 0)
 	    {
+	      /* If nfd begins at the prompt, or before the invisible
+		 characters in the prompt, we need to adjust _rl_last_c_pos
+		 in a multibyte locale to account for the wrap offset and
+		 set cpos_adjusted accordingly. */
 	      _rl_output_some_chars (nfd, temp);
 	      _rl_last_c_pos += col_temp;		/* XXX */
+	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
+		{
+		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
+		    {
+		      _rl_last_c_pos -= wrap_offset;
+		      cpos_adjusted = 1;
+		    }
+		}
 	    }
 	  lendiff = (oe - old) - (ne - new);
 	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
@@ -1721,7 +1803,7 @@
   int woff;			/* number of invisible chars on current line */
   int cpos, dpos;		/* current and desired cursor positions */
 
-  woff = W_OFFSET (_rl_last_v_pos, wrap_offset);
+  woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
   cpos = _rl_last_c_pos;
 #if defined (HANDLE_MULTIBYTE)
   /* If we have multibyte characters, NEW is indexed by the buffer point in
@@ -1732,7 +1814,14 @@
   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     {
       dpos = _rl_col_width (data, 0, new);
-      if (dpos > prompt_last_invisible)		/* XXX - don't use woff here */
+      /* Use NEW when comparing against the last invisible character in the
+	 prompt string, since they're both buffer indices and DPOS is a
+	 desired display position. */
+      if ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
+	  (prompt_physical_chars > _rl_screenwidth &&
+	   _rl_last_v_pos == prompt_last_screen_line &&
+	   wrap_offset != woff &&
+	   new > (prompt_last_invisible-_rl_screenwidth-wrap_offset)))
 	{
 	  dpos -= woff;
 	  /* Since this will be assigned to _rl_last_c_pos at the end (more
@@ -2380,6 +2469,8 @@
 
   if (end <= start)
     return 0;
+  if (MB_CUR_MAX == 1 || rl_byte_oriented)
+    return (end - start);
 
   memset (&ps, 0, sizeof (mbstate_t));
 
diff -Nru readline-5.2-orig/histexpand.c readline-5.2/histexpand.c
--- readline-5.2-orig/histexpand.c	2006-07-29 22:44:17.000000000 +0200
+++ readline-5.2/histexpand.c	2009-02-19 08:20:11.000000000 +0100
@@ -203,7 +203,7 @@
     }
 
   /* Only a closing `?' or a newline delimit a substring search string. */
-  for (local_index = i; c = string[i]; i++)
+  for (local_index = i; (c = string[i]); i++)
     {
 #if defined (HANDLE_MULTIBYTE)
       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
diff -Nru readline-5.2-orig/input.c readline-5.2/input.c
--- readline-5.2-orig/input.c	2006-08-16 21:15:16.000000000 +0200
+++ readline-5.2/input.c	2009-02-19 15:56:38.000000000 +0100
@@ -133,8 +133,11 @@
     return (0);
 
   *key = ibuffer[pop_index++];
-
+#if 0
   if (pop_index >= ibuffer_len)
+#else
+  if (pop_index > ibuffer_len)
+#endif
     pop_index = 0;
 
   return (1);
@@ -151,7 +154,7 @@
     {
       pop_index--;
       if (pop_index < 0)
-	pop_index = ibuffer_len - 1;
+	pop_index = ibuffer_len;
       ibuffer[pop_index] = key;
       return (1);
     }
@@ -250,7 +253,8 @@
       while (chars_avail--)
 	{
 	  k = (*rl_getc_function) (rl_instream);
-	  rl_stuff_char (k);
+	  if (rl_stuff_char (k) == 0)
+	    break;			/* some problem; no more room */
 	  if (k == NEWLINE || k == RETURN)
 	    break;
 	}
@@ -373,7 +377,11 @@
       RL_SETSTATE (RL_STATE_INPUTPENDING);
     }
   ibuffer[push_index++] = key;
+#if 0
   if (push_index >= ibuffer_len)
+#else
+  if (push_index > ibuffer_len)
+#endif
     push_index = 0;
 
   return 1;
@@ -420,7 +428,7 @@
   else
     {
       /* If input is coming from a macro, then use that. */
-      if (c = _rl_next_macro_key ())
+      if ((c = _rl_next_macro_key ()))
 	return (c);
 
       /* If the user has an event function, then call it periodically. */
@@ -513,20 +521,26 @@
      char *mbchar;
      int size;
 {
-  int mb_len = 0;
+  int mb_len, c;
   size_t mbchar_bytes_length;
   wchar_t wc;
   mbstate_t ps, ps_back;
 
   memset(&ps, 0, sizeof (mbstate_t));
   memset(&ps_back, 0, sizeof (mbstate_t));
-  
+
+  mb_len = 0;  
   while (mb_len < size)
     {
       RL_SETSTATE(RL_STATE_MOREINPUT);
-      mbchar[mb_len++] = rl_read_key ();
+      c = rl_read_key ();
       RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
+      if (c < 0)
+	break;
+
+      mbchar[mb_len++] = c;
+
       mbchar_bytes_length = mbrtowc (&wc, mbchar, mb_len, &ps);
       if (mbchar_bytes_length == (size_t)(-1))
 	break;		/* invalid byte sequence for the current locale */
@@ -564,7 +578,7 @@
 
   c = first;
   memset (mb, 0, mlen);
-  for (i = 0; i < mlen; i++)
+  for (i = 0; c >= 0 && i < mlen; i++)
     {
       mb[i] = (char)c;
       memset (&ps, 0, sizeof (mbstate_t));
diff -Nru readline-5.2-orig/isearch.c readline-5.2/isearch.c
--- readline-5.2-orig/isearch.c	2005-12-26 23:18:53.000000000 +0100
+++ readline-5.2/isearch.c	2009-02-19 15:53:05.000000000 +0100
@@ -327,8 +327,15 @@
   rl_command_func_t *f;
 
   f = (rl_command_func_t *)NULL;
- 
- /* Translate the keys we do something with to opcodes. */
+
+  if (c < 0)
+    {
+      cxt->sflags |= SF_FAILED;
+      cxt->history_pos = cxt->last_found_line;
+      return -1;
+    }
+
+  /* Translate the keys we do something with to opcodes. */
   if (c >= 0 && _rl_keymap[c].type == ISFUNC)
     {
       f = _rl_keymap[c].function;
diff -Nru readline-5.2-orig/misc.c readline-5.2/misc.c
--- readline-5.2-orig/misc.c	2005-12-26 23:20:46.000000000 +0100
+++ readline-5.2/misc.c	2009-02-19 15:53:05.000000000 +0100
@@ -146,6 +146,8 @@
 	  rl_restore_prompt ();
 	  rl_clear_message ();
 	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
+	  if (key < 0)
+	    return -1;
 	  return (_rl_dispatch (key, _rl_keymap));
 	}
     }
diff -Nru readline-5.2-orig/pbuild.xml readline-5.2/pbuild.xml
--- readline-5.2-orig/pbuild.xml	1970-01-01 01:00:00.000000000 +0100
+++ readline-5.2/pbuild.xml	2009-02-19 16:06:59.000000000 +0100
@@ -0,0 +1,129 @@
+<!--
+
+This file is part of the yaosp build system
+
+Copyright (c) 2009 Zoltan Kovacs
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of version 2 of the GNU General Public License
+as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+-->
+
+<build default="all">
+    <array name="files">
+        <item>readline.c</item>
+        <item>funmap.c</item>
+        <item>keymaps.c</item>
+        <item>vi_mode.c</item>
+        <item>parens.c</item>
+        <item>rltty.c</item>
+        <item>complete.c</item>
+        <item>bind.c</item>
+        <item>isearch.c</item>
+        <item>display.c</item>
+        <item>signals.c</item>
+        <item>util.c</item>
+        <item>kill.c</item>
+        <item>undo.c</item>
+        <item>macro.c</item>
+        <item>input.c</item>
+        <item>callback.c</item>
+        <item>terminal.c</item>
+        <item>xmalloc.c</item>
+        <item>history.c</item>
+        <item>histsearch.c</item>
+        <item>histexpand.c</item>
+        <item>histfile.c</item>
+        <item>nls.c</item>
+        <item>search.c</item>
+        <item>shell.c</item>
+        <item>savestring.c</item>
+        <item>tilde.c</item>
+        <item>text.c</item>
+        <item>misc.c</item>
+        <item>compat.c</item>
+        <item>mbutil.c</item>
+    </array>
+
+    <array name="headers_to_install">
+        <item>chardefs.h</item>
+        <item>history.h</item>
+        <item>keymaps.h</item>
+        <item>readline.h</item>
+        <item>rlconf.h</item>
+        <item>rlstdc.h</item>
+        <item>rltypedefs.h</item>
+        <item>tilde.h</item>
+    </array>
+
+    <target name="clean">
+        <delete>objs/*</delete>
+        <rmdir>objs</rmdir>
+    </target>
+
+    <target name="prepare" type="private">
+        <mkdir>objs</mkdir>
+    </target>
+
+    <target name="compile">
+        <call target="prepare"/>
+
+        <echo>Compiling readline 5.2</echo>
+
+        <for var="i" array="${files}">
+            <echo>-> ${i}</echo>
+            <gcc>
+                <input>${i}</input>
+                <output>objs/filename(${i}).o</output>
+                <include>../../../include</include>
+                <include>../../../../build/crosscompiler/lib/gcc/i686-pc-yaosp/4.3.3/include</include>
+                <include>./</include>
+                <flag>-c</flag>
+                <flag>-O2</flag>
+                <flag>-m32</flag>
+                <flag>-Wall</flag>
+                <flag>-nostdinc</flag>
+                <flag>-nostdlib</flag>
+                <flag>-fno-builtin</flag>
+                <flag>-fno-strict-aliasing</flag>
+                <define key="HAVE_CONFIG_H"/>
+                <define key="_POSIX_VERSION"/>
+            </gcc>
+        </for>
+
+        <echo>Linking readline 5.2</echo>
+        <echo>-> objs/libreadline.a</echo>
+        
+        <exec executable="ar">
+            <arg>-rc</arg>
+            <arg>objs/libreadline.a</arg>
+            <arg>objs/*.o</arg>
+        </exec>
+    </target>
+
+    <target name="install">
+        <echo>Installing readline 5.2 headers</echo>
+
+        <mkdir>../../../include/readline</mkdir>
+        <for var="i" array="${headers_to_install}">
+            <echo>-> ${i}</echo>
+            <copy from="${i}" to="../../../include/readline/${i}"/>
+        </for>
+    </target>
+
+    <target name="all">
+        <call target="clean"/>
+        <call target="compile"/>
+        <call target="install"/>
+    </target>
+</build>
diff -Nru readline-5.2-orig/readline.c readline-5.2/readline.c
--- readline-5.2-orig/readline.c	2006-08-16 21:00:36.000000000 +0200
+++ readline-5.2/readline.c	2009-02-19 15:53:05.000000000 +0100
@@ -90,7 +90,9 @@
 static void bind_arrow_keys PARAMS((void));
 
 static void readline_default_bindings PARAMS((void));
+#if 0
 static void reset_default_bindings PARAMS((void));
+#endif
 
 static int _rl_subseq_result PARAMS((int, Keymap, int, int));
 static int _rl_subseq_getchar PARAMS((int));
@@ -645,6 +647,11 @@
   if ((cxt->flags & KSEQ_DISPATCHED) == 0)
     {
       nkey = _rl_subseq_getchar (cxt->okey);
+      if (nkey < 0)
+	{
+	  _rl_abort_internal ();
+	  return -1;
+	}
       r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
       cxt->flags |= KSEQ_DISPATCHED;
     }
@@ -1072,6 +1079,7 @@
     rl_tty_set_default_bindings (_rl_keymap);
 }
 
+#if 0
 /* Reset the default bindings for the terminal special characters we're
    interested in back to rl_insert and read the new ones. */
 static void
@@ -1083,6 +1091,7 @@
       rl_tty_set_default_bindings (_rl_keymap);
     }
 }
+#endif
 
 /* Bind some common arrow key sequences in MAP. */
 static void
diff -Nru readline-5.2-orig/search.c readline-5.2/search.c
--- readline-5.2-orig/search.c	2006-03-14 16:31:35.000000000 +0100
+++ readline-5.2/search.c	2009-02-19 08:20:20.000000000 +0100
@@ -211,7 +211,7 @@
   rl_end = rl_point = 0;
 
   p = _rl_make_prompt_for_search (pchar ? pchar : ':');
-  rl_message ("%s", p, 0);
+  rl_message ("%s", p);
   free (p);
 
   RL_SETSTATE(RL_STATE_NSEARCH);
diff -Nru readline-5.2-orig/shell.c readline-5.2/shell.c
--- readline-5.2-orig/shell.c	2005-05-07 20:42:02.000000000 +0200
+++ readline-5.2/shell.c	2009-02-19 08:54:19.000000000 +0100
@@ -124,7 +124,9 @@
 sh_set_lines_and_columns (lines, cols)
      int lines, cols;
 {
+#if defined (HAVE_SETENV) || defined (HAVE_PUTENV)
   char *b;
+#endif
 
 #if defined (HAVE_SETENV)
   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
@@ -160,7 +162,9 @@
 sh_get_home_dir ()
 {
   char *home_dir;
+#if defined (HAVE_GETPWUID)
   struct passwd *entry;
+#endif
 
   home_dir = (char *)NULL;
 #if defined (HAVE_GETPWUID)
diff -Nru readline-5.2-orig/support/shobj-conf readline-5.2/support/shobj-conf
--- readline-5.2-orig/support/shobj-conf	2006-04-11 15:15:43.000000000 +0200
+++ readline-5.2/support/shobj-conf	2009-02-19 15:56:54.000000000 +0100
@@ -10,7 +10,7 @@
 # Chet Ramey
 # chet@po.cwru.edu
 
-# Copyright (C) 1996-2002 Free Software Foundation, Inc.
+# Copyright (C) 1996-2007 Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -114,7 +114,7 @@
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
 	;;
 
-freebsd2* | netbsd*)
+freebsd2*)
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD=ld
 	SHOBJ_LDFLAGS='-x -Bshareable'
@@ -125,7 +125,7 @@
 
 # FreeBSD-3.x ELF
 freebsd[3-9]*|freebsdelf[3-9]*|freebsdaout[3-9]*|dragonfly*)
-	SHOBJ_CFLAGS=-fpic
+	SHOBJ_CFLAGS=-fPIC
 	SHOBJ_LD='${CC}'
 
 	if [ -x /usr/bin/objformat ] && [ "`/usr/bin/objformat`" = "elf" ]; then
@@ -142,7 +142,7 @@
 	;;
 
 # Darwin/MacOS X
-darwin8*)
+darwin[89]*)
 	SHOBJ_STATUS=supported
 	SHLIB_STATUS=supported
 	
@@ -153,7 +153,7 @@
 	SHLIB_LIBVERSION='$(SHLIB_MAJOR)$(SHLIB_MINOR).$(SHLIB_LIBSUFF)'
 	SHLIB_LIBSUFF='dylib'
 
-	SHOBJ_LDFLAGS='-undefined dynamic_lookup'
+	SHOBJ_LDFLAGS='-dynamiclib -dynamic -undefined dynamic_lookup -arch_only `/usr/bin/arch`'
 	SHLIB_XLDFLAGS='-dynamiclib -arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'
 
 	SHLIB_LIBS='-lncurses'	# see if -lcurses works on MacOS X 10.1 
@@ -171,7 +171,7 @@
 	SHLIB_LIBSUFF='dylib'
 
 	case "${host_os}" in
-	darwin[78]*)	SHOBJ_LDFLAGS=''
+	darwin[789]*)	SHOBJ_LDFLAGS=''
 			SHLIB_XLDFLAGS='-dynamiclib -arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'
 			;;
 	*)		SHOBJ_LDFLAGS='-dynamic'
@@ -182,7 +182,7 @@
 	SHLIB_LIBS='-lncurses'	# see if -lcurses works on MacOS X 10.1 
 	;;
 
-openbsd*)
+openbsd*|netbsd*)
 	SHOBJ_CFLAGS=-fPIC
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared'
@@ -247,7 +247,7 @@
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 
-aix4.[2-9]*-*gcc*)		# lightly tested by jik@cisco.com
+aix4.[2-9]*-*gcc*|aix[5-9].*-*gcc*)		# lightly tested by jik@cisco.com
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD='ld'
 	SHOBJ_LDFLAGS='-bdynamic -bnoentry -bexpall'
@@ -258,7 +258,7 @@
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 
-aix4.[2-9]*)
+aix4.[2-9]*|aix[5-9].*)
 	SHOBJ_CFLAGS=-K
 	SHOBJ_LD='ld'
 	SHOBJ_LDFLAGS='-bdynamic -bnoentry -bexpall'
@@ -329,7 +329,7 @@
 	SHOBJ_LD='${CC}'
 	# if you have problems linking here, moving the `-Wl,+h,$@' from
 	# SHLIB_XLDFLAGS to SHOBJ_LDFLAGS has been reported to work
-	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,+s'
+	SHOBJ_LDFLAGS='-shared -fpic -Wl,-b -Wl,+s'
 
 	SHLIB_XLDFLAGS='-Wl,+h,$@ -Wl,+b,$(libdir)'
 	SHLIB_LIBSUFF='sl'
diff -Nru readline-5.2-orig/text.c readline-5.2/text.c
--- readline-5.2-orig/text.c	2006-07-28 17:55:27.000000000 +0200
+++ readline-5.2/text.c	2009-02-19 15:53:05.000000000 +0100
@@ -857,6 +857,9 @@
   c = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
+  if (c < 0)
+    return -1;
+
 #if defined (HANDLE_SIGNALS)
   if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
     _rl_restore_tty_signals ();
@@ -1520,6 +1523,9 @@
 
   mb_len = _rl_read_mbchar (mbchar, MB_LEN_MAX);
 
+  if (mb_len <= 0)
+    return -1;
+
   if (count < 0)
     return (_rl_char_search_internal (-count, bdir, mbchar, mb_len));
   else
@@ -1536,6 +1542,9 @@
   c = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
+  if (c < 0)
+    return -1;
+
   if (count < 0)
     return (_rl_char_search_internal (-count, bdir, c));
   else
diff -Nru readline-5.2-orig/tilde.c readline-5.2/tilde.c
--- readline-5.2-orig/tilde.c	2006-04-11 17:19:32.000000000 +0200
+++ readline-5.2/tilde.c	2009-02-19 08:21:48.000000000 +0100
@@ -19,6 +19,8 @@
    along with Readline; see the file COPYING.  If not, write to the Free
    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
+#define READLINE_LIBRARY
+
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
@@ -196,7 +198,7 @@
   int result_size, result_index;
 
   result_index = result_size = 0;
-  if (result = strchr (string, '~'))
+  if ((result = strchr (string, '~')))
     result = (char *)xmalloc (result_size = (strlen (string) + 16));
   else
     result = (char *)xmalloc (result_size = (strlen (string) + 1));
diff -Nru readline-5.2-orig/undo.c readline-5.2/undo.c
--- readline-5.2-orig/undo.c	2006-05-22 02:20:41.000000000 +0200
+++ readline-5.2/undo.c	2009-02-19 08:54:59.000000000 +0100
@@ -141,6 +141,8 @@
 
   list = head;
   new = 0;
+  roving = 0;
+
   while (list)
     {
       c = _rl_copy_undo_entry (list);
diff -Nru readline-5.2-orig/vi_mode.c readline-5.2/vi_mode.c
--- readline-5.2-orig/vi_mode.c	2006-07-29 22:42:28.000000000 +0200
+++ readline-5.2/vi_mode.c	2009-02-19 15:53:05.000000000 +0100
@@ -886,6 +886,13 @@
   RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
+  if (c < 0)
+    {
+      *nextkey = 0;
+      return -1;
+    }
+
   *nextkey = c;
 
   if (!member (c, vi_motion))
@@ -902,6 +909,11 @@
 	  RL_SETSTATE(RL_STATE_MOREINPUT);
 	  c = rl_read_key ();	/* real command */
 	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	  if (c < 0)
+	    {
+	      *nextkey = 0;
+	      return -1;
+	    }
 	  *nextkey = c;
 	}
       else if (key == c && (key == 'd' || key == 'y' || key == 'c'))
@@ -1224,14 +1236,22 @@
 _rl_vi_callback_char_search (data)
      _rl_callback_generic_arg *data;
 {
+  int c;
 #if defined (HANDLE_MULTIBYTE)
-  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
+  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
 #else
   RL_SETSTATE(RL_STATE_MOREINPUT);
-  _rl_vi_last_search_char = rl_read_key ();
+  c = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
 #endif
 
+  if (c <= 0)
+    return -1;
+
+#if !defined (HANDLE_MULTIBYTE)
+  _rl_vi_last_search_char = c;
+#endif
+
   _rl_callback_func = 0;
   _rl_want_redisplay = 1;
 
@@ -1247,6 +1267,7 @@
 rl_vi_char_search (count, key)
      int count, key;
 {
+  int c;
 #if defined (HANDLE_MULTIBYTE)
   static char *target;
   static int tlen;
@@ -1293,11 +1314,17 @@
       else
 	{
 #if defined (HANDLE_MULTIBYTE)
-	  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
+	  c = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
+	  if (c <= 0)
+	    return -1;
+	  _rl_vi_last_search_mblen = c;
 #else
 	  RL_SETSTATE(RL_STATE_MOREINPUT);
-	  _rl_vi_last_search_char = rl_read_key ();
+	  c = rl_read_key ();
 	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	  if (c < 0)
+	    return -1;
+	  _rl_vi_last_search_char = c;
 #endif
 	}
     }
@@ -1467,6 +1494,9 @@
   c = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
+  if (c < 0)
+    return -1;
+
 #if defined (HANDLE_MULTIBYTE)
   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     c = _rl_read_mbstring (c, mb, mlen);
@@ -1485,6 +1515,9 @@
 
   _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);
 
+  if (c < 0)
+    return -1;
+
   _rl_callback_func = 0;
   _rl_want_redisplay = 1;
 
@@ -1516,6 +1549,9 @@
   else
     _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);
 
+  if (c < 0)
+    return -1;
+
   return (_rl_vi_change_char (count, c, mb));
 }
 
@@ -1650,7 +1686,7 @@
   ch = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
-  if (ch < 'a' || ch > 'z')
+  if (ch < 0 || ch < 'a' || ch > 'z')	/* make test against 0 explicit */
     {
       rl_ding ();
       return -1;
@@ -1702,7 +1738,7 @@
       rl_point = rl_mark;
       return 0;
     }
-  else if (ch < 'a' || ch > 'z')
+  else if (ch < 0 || ch < 'a' || ch > 'z')	/* make test against 0 explicit */
     {
       rl_ding ();
       return -1;
