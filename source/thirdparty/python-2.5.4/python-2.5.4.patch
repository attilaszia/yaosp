diff -Nru Python-2.5.4-orig/Lib/yaosp.py Python-2.5.4/Lib/yaosp.py
--- Python-2.5.4-orig/Lib/yaosp.py	1970-01-01 01:00:00.000000000 +0100
+++ Python-2.5.4/Lib/yaosp.py	2009-04-20 20:15:38.000000000 +0200
@@ -0,0 +1,139 @@
+# yaosp bindings for python
+#
+# Copyright (c) 2009 Attila Magyar
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of version 2 of the GNU General Public License
+# as published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+import _yaosp as yo
+import os
+import errno
+
+INFINITE_TIMEOUT = -1
+
+class IpcError( yo.error ): pass
+
+class IpcReceiveException( IpcError ):
+	def __init__(self, errno):
+		self.errno = errno
+		self.message = 'IPC receive error: ' + os.strerror( errno )
+
+	def __str__(self):
+		return "%s (%d)" % ( self.message, self.errno )
+
+class IpcTimeoutException( IpcReceiveException ):
+	def __init__(self, msg = ""):
+		IpcReceiveException.__init__( self, -errno.ETIME )
+		if msg: self.message += '; ' + msg
+
+
+class IpcMessageListener(object):
+	def received( self, message, code, size ): print "Message %s; code %d" % ( message, code )
+	def error( self, ipcReceiveException ): print ipcReceiveException
+
+class IpcClient(object):
+
+	def __init__( self, name="", port=-1 ):
+		if not name and port < 0:
+			raise ValueError( "No IPC port or name parameter is passed" )
+		self.name = name
+		self.port = port
+
+	def  open( self ):
+		if self.port < 0:
+			self.port = yo.get_named_ipc( self.name )
+			if self.port < 0:
+				raise IpcError( "Can't query IPC by name %s" % ( self.name ) )
+		return self.port
+
+	def send( self, message, code = 0 ):
+		if self.port < 0:
+			raise IpcError( 'IPC %s is not opened' % ( self.name ) )
+
+		return yo.send_ipc_message( self.port, code, message )
+
+class IpcServer(object):
+
+	def __init__(self, name = "", max_message_size = 32):
+		self.port = -1
+		self.name = name
+		self.max_message_size = max_message_size
+		self.stop = True
+		self._listeners = []
+		self._timeout = 1000
+
+	def add_listener( self, listener ):
+		if listener in self._listeners:
+			return False
+		self._listeners.append( listener )
+		return True
+
+	def delete_listener( self, listener ):
+		return self._listeners.remove( listener )
+
+	def clear_listeners( self ):
+		self._listeners = []
+
+	def open( self ):
+		self.port = yo.create_ipc_port()
+		if self.port < 0:
+			raise IpcError( "Can't create ipc port: %d" % ( self.port ) )
+
+		if self.name:
+			ecode = yo.register_named_ipc( self.name, self.port )
+			if ecode < 0:
+				self.port = -1
+				raise IpcError( "Can't not register ipc port: %s; err: %d" % ( self.name, ecode ) )
+
+		return self.port
+
+	def stop( self ):
+		self.stop = True
+
+	def read( self, timeout= INFINITE_TIMEOUT ):
+		if self.port < 0:
+			raise IpcError( 'IPC %s is not opened' % ( self.name ) )
+
+		result, code, data = yo.recv_ipc_message( self.port, self.max_message_size, timeout )
+		if result == -errno.ETIME:
+			raise IpcTimeoutException( "IPC timeout: %d" % ( self.port ) )
+		if result < 0:
+			raise IpcReceiveException( result )
+
+		return result, code, data
+
+	def _notify_msg_listeners( self, message, code, size ):
+		for listener in self._listeners:
+			listener.received( message, code, size )
+
+	def _notify_error_listeners( self, exception ):
+		for listener in self._listeners:
+			listener.error( exception )
+
+	def start_loop( self ):
+		self.stop = False
+		self._event_loop()
+
+	def _event_loop( self ):
+		if self.port < 0:
+			raise IpcError( 'IPC port is not opened' )
+
+		while not self.stop:
+			try:
+				result, code, message = self.read( timeout=self._timeout )
+			except IpcTimeoutException, e:
+				pass # ignore
+			except IpcReceiveException, e:
+				self._notify_error_listeners( e )
+			else:
+				self._notify_msg_listeners( message, code, result )
diff -Nru Python-2.5.4-orig/Modules/_yaospmodule.c Python-2.5.4/Modules/_yaospmodule.c
--- Python-2.5.4-orig/Modules/_yaospmodule.c	1970-01-01 01:00:00.000000000 +0100
+++ Python-2.5.4/Modules/_yaospmodule.c	2009-04-20 20:21:29.000000000 +0200
@@ -0,0 +1,415 @@
+/* yaosp bindings for python
+ *
+ * Copyright (c) 2009 Attila Magyar
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <Python.h>
+#include <yaosp/sysinfo.h>
+#include <yaosp/time.h>
+#include <yaosp/debug.h>
+#include <yaosp/ipc.h>
+
+#define 	MODULE_NAME 	"_yaosp"
+#define 	EXCEPTION_NAME	"_yaosp.error"
+
+static PyObject *yaospError; // Exception object
+
+static PyObject *yaosp_get_memory_info( PyObject *self, PyObject *args ) {
+	int error;
+	memory_info_t memory_info;
+
+	error = get_memory_info( &memory_info );
+
+	if ( error < 0 ) {
+		PyErr_SetString(yaospError, "Can't get memory information");
+		return NULL;
+	}
+
+	uint32_t total_mem = memory_info.total_page_count * getpagesize();
+	uint32_t free_mem = memory_info.free_page_count * getpagesize();
+
+	return Py_BuildValue("(ii)", total_mem, free_mem) ;
+}
+
+static PyObject *yaosp_get_processor_info( PyObject *self, PyObject *args ) {
+	uint32_t i;
+	uint32_t processor_count;
+
+	processor_info_t* info;
+	processor_info_t* info_table;
+
+	PyObject *pylist, *item;
+
+	processor_count = get_processor_count();
+
+	if ( processor_count == 0 ) {
+		Py_RETURN_NONE;
+	}
+
+	info_table = ( processor_info_t* )malloc( sizeof( processor_info_t ) * processor_count );
+
+	if ( info_table == NULL ) {
+		return PyErr_NoMemory();
+	}
+
+	processor_count = get_processor_info( info_table, processor_count );
+
+	pylist = PyList_New(0);
+
+	if ( pylist == NULL ) {
+		goto cp_err;
+	}
+
+	for ( i = 0, info = info_table; i < processor_count; i++, info++ ) {
+		if ( ( !info->present ) || ( !info->running ) ) {
+			continue;
+		}
+
+		item = Py_BuildValue("{s:s,s:i}",
+			"model", info->name,
+			"speed", ( uint32_t )( info->core_speed / 1000000 ) );
+
+		PyList_Append( pylist, item );
+	}
+
+cp_err:
+	free( info_table );
+
+	return pylist;
+}
+
+static PyObject *yaosp_get_kernel_info( PyObject *self, PyObject *args ) {
+	int error;
+	char ver[ 32 ];
+	char build[ 128 ];
+	kernel_info_t kernel_info;
+
+	error = get_kernel_info( &kernel_info );
+
+	if ( error < 0 ) {
+		PyErr_SetString(yaospError, "Can't get kernel information");
+		return NULL;
+	}
+
+	snprintf( ver, sizeof(ver), "%d.%d.%d",
+		kernel_info.major_version,
+		kernel_info.minor_version,
+		kernel_info.release_version
+	);
+	snprintf( build, sizeof(build), "%s %s",
+		kernel_info.build_date,
+		kernel_info.build_time
+	);
+
+	return Py_BuildValue("{s:s,s:s}", "version", ver, "build", build  );
+}
+
+static PyObject *yaosp_get_module_info( PyObject *self, PyObject *args ) {
+	int error;
+	uint32_t i;
+	uint32_t module_count;
+	module_info_t* info;
+	module_info_t* info_table;
+	PyObject *pylist, *item;
+
+	module_count = get_module_count();
+
+	if ( module_count > 0 ) {
+		info_table = ( module_info_t* )malloc( sizeof( module_info_t ) * module_count );
+
+		if ( info_table == NULL ) {
+			return PyErr_NoMemory();
+		}
+
+		error = get_module_info( info_table, module_count );
+
+		if ( error < 0 ) {
+			free( info_table );
+			PyErr_SetString(yaospError, "Can't get module information");
+			return NULL;
+		}
+
+		pylist = PyList_New( module_count );
+
+		if ( pylist == NULL ) {
+			free( info_table );
+			return NULL;
+		}
+
+		for ( i = 0, info = info_table; i < module_count; i++, info++ ) {
+			item = Py_BuildValue( "s", info->name );
+			PyList_SetItem( pylist, i, item );
+		}
+
+		free( info_table );
+
+		return pylist;
+    }
+
+    return Py_BuildValue( "()" );
+}
+
+static PyObject *yaosp_get_process_info( PyObject *self, PyObject *args ) {
+	uint32_t process_count;
+	process_info_t* process;
+	process_info_t* process_table;
+	PyObject *pylist, *item;
+
+	process_count = get_process_count();
+
+	if ( process_count > 0 ) {
+		uint32_t i;
+
+		process_table = ( process_info_t* )malloc( sizeof( process_info_t ) * process_count );
+		if ( process_table == NULL ) {
+			return PyErr_NoMemory();
+		}
+
+		process_count = get_process_info( process_table, process_count );
+
+		pylist = PyList_New( process_count );
+
+		if (pylist == NULL ) {
+			free( process_table );
+			return NULL;
+		}
+
+		for ( i = 0, process = process_table; i < process_count; i++, process++ ) {
+			item = Py_BuildValue("{s:i,s:s,s:K,s:K}", // TODO warning 'K' is an undocumented format string value
+				"id", process->id,
+				"name", process->name,
+				"vmem",	process->vmem_size,
+				"pmem", process->pmem_size
+			);
+
+			PyList_SetItem( pylist, i, item );
+		}
+
+		free( process_table );
+
+		return pylist;
+	}
+
+	return Py_BuildValue("()");
+}
+
+static PyObject *yaosp_get_thread_info( PyObject *self, PyObject *args ) {
+	uint32_t thread_count;
+	thread_info_t* thread;
+	thread_info_t* thread_table;
+	int pid;
+	PyObject *pylist, *item;
+
+	if (!PyArg_ParseTuple( args, "i", &pid ) ) {
+		return NULL;
+	}
+
+	thread_count = get_thread_count_for_process( pid );
+
+	if ( thread_count > 0 ) {
+		uint32_t i;
+
+		thread_table = ( thread_info_t* )malloc( sizeof( thread_info_t ) * thread_count );
+
+		if ( thread_table == NULL ) {
+			return PyErr_NoMemory();
+		}
+
+		thread_count = get_thread_info_for_process( pid, thread_table, thread_count );
+
+		pylist = PyList_New(thread_count);
+
+		if ( pylist == NULL ) {
+			free( thread_table );
+			return NULL;
+		}
+
+		for ( i = 0, thread = thread_table; i < thread_count; i++, thread++ ) {
+			item = Py_BuildValue("{s:i,s:s,s:i,s:K}", // TODO warning 'K' is an undocumented format string value
+				"id", thread->id,
+				"name",	thread->name,
+				"state", thread->state,
+				"cputime", thread->cpu_time
+			);
+
+			PyList_SetItem(pylist, i, item);
+		}
+
+		free( thread_table );
+
+		return pylist;
+	}
+
+	return Py_BuildValue("()");
+}
+
+static PyObject *yaosp_dbprint( PyObject *self, PyObject *args ) {
+	const char* txt;
+
+	if ( !PyArg_ParseTuple(args, "s", &txt) ) {
+		return NULL;
+	}
+
+	dbprintf( "%s\n", txt );
+
+	Py_RETURN_NONE;
+}
+
+static PyObject *yaosp_system_time( PyObject *self, PyObject *args ) {
+	time_t sys_time = get_system_time();
+
+	return Py_BuildValue("K", sys_time) ;
+}
+
+static PyObject *yaosp_boot_time( PyObject *self, PyObject *args ) {
+	time_t boot_time = get_boot_time();
+
+	return Py_BuildValue("K", boot_time) ;
+}
+
+static PyObject *yaosp_uptime( PyObject *self, PyObject *args ) {
+	time_t sys_time = get_system_time();
+	time_t boot_time = get_boot_time();
+
+	return Py_BuildValue("K", sys_time - boot_time) ;
+}
+
+static PyObject *yaosp_ipc_create_port( PyObject *self, PyObject *args ) {
+	ipc_port_id id = create_ipc_port();
+	return Py_BuildValue("i", id) ;
+}
+
+static PyObject *yaosp_ipc_send_message( PyObject *self, PyObject *args ) {
+	ipc_port_id id;
+	uint32_t code;
+	int result, len;
+	const char* data;
+
+	if ( !PyArg_ParseTuple( args, "iis#", &id, &code, &data, &len ) ) {
+		return NULL;
+	}
+
+	result = send_ipc_message( id, code, (void*)data, len );
+
+	return Py_BuildValue( "i",result ) ;
+}
+
+static PyObject *yaosp_ipc_receive_message( PyObject *self, PyObject *args ) {
+	ipc_port_id id;
+	uint32_t code;
+	size_t size;
+	int ptimeout;
+	uint64_t timeout;
+	int result;
+	char* buffer;
+
+	if ( !PyArg_ParseTuple( args, "iii", &id, &size, &ptimeout ) ) {
+		return NULL;
+	}
+
+	if ( ptimeout < 0 ) {
+		timeout = INFINITE_TIMEOUT;
+	}
+	else {
+		timeout = (uint64_t)ptimeout * 1000;
+	}
+
+	buffer = (char*)malloc( size * sizeof(char) +1 ); // allocate +1 byte for chr #0
+	if ( buffer == NULL )  {
+		return PyErr_NoMemory();
+	}
+
+	result = recv_ipc_message( id, &code, buffer, size,  timeout );
+
+	if ( result <= 0 )  {
+		code = -1;
+		free(buffer);
+		return Py_BuildValue( "(i,i,s)", result, code, "" );
+	}
+
+	buffer[ size ] = 0; // terminate string with #0
+
+	// return a tupple (len, code, data[:len],)
+	PyObject *retVal = Py_BuildValue( "(i,i,s#)", result, code, buffer, result );
+	free(buffer);
+
+	return retVal;
+}
+
+static PyObject *yaosp_register_named_ipc_port( PyObject *self, PyObject *args ) {
+	ipc_port_id id;
+	const char *name;
+	int result;
+
+	if ( !PyArg_ParseTuple( args, "si", &name, &id ) ) {
+		return NULL;
+	}
+
+	result = register_named_ipc_port( name, id );
+	return Py_BuildValue( "i", result ) ;
+}
+
+static PyObject *yaosp_get_named_ipc_port( PyObject *self, PyObject *args ) {
+	ipc_port_id id;
+	const char *name;
+	int result;
+
+	if ( !PyArg_ParseTuple( args, "s", &name ) ) {
+		return NULL;
+	}
+
+	result = get_named_ipc_port( name, &id );
+
+	if ( result >= 0 ) {
+		return Py_BuildValue( "i", id ) ;
+	}
+	return Py_BuildValue( "i", result ) ;
+}
+
+// TODO convert boottime, systemtime, uptime to datetime format
+
+static PyMethodDef yaospMethods[] = {
+	{"memory_info", yaosp_get_memory_info, METH_VARARGS, "Get total and free memory"},
+	{"processor_info", yaosp_get_processor_info, METH_VARARGS, "Get processor information"},
+	{"kernel_info", yaosp_get_kernel_info, METH_VARARGS, "Get kernel information"},
+	{"module_info", yaosp_get_module_info, METH_VARARGS, "Get module information"},
+	{"process_info", yaosp_get_process_info, METH_VARARGS, "Get process list"},
+	{"thread_info", yaosp_get_thread_info, METH_VARARGS, "Get thread info for the specified pid"},
+	{"dbprint", yaosp_dbprint, METH_VARARGS, "Debug print"},
+	{"boot_time", yaosp_boot_time, METH_VARARGS, "Boot time"},
+	{"system_time", yaosp_system_time, METH_VARARGS, "System time"},
+	{"uptime", yaosp_uptime, METH_VARARGS, "System uptime"},
+	{"create_ipc_port", yaosp_ipc_create_port, METH_VARARGS, "Create IPC port"},
+	{"send_ipc_message", yaosp_ipc_send_message, METH_VARARGS, "Send binary data via IPC"},
+	{"recv_ipc_message", yaosp_ipc_receive_message, METH_VARARGS, "Receive IPC message"},
+	{"register_named_ipc", yaosp_register_named_ipc_port, METH_VARARGS, "Register named IPC port"},
+	{"get_named_ipc", yaosp_get_named_ipc_port, METH_VARARGS, "Get named IPC port"},
+	{NULL, NULL, 0, NULL}
+};
+
+PyMODINIT_FUNC inityaosp(void) {
+	PyObject *module = Py_InitModule( MODULE_NAME , yaospMethods );
+
+	if (module == NULL) {
+		return;
+	}
+
+	// Create and register yaosp exception class
+	yaospError = PyErr_NewException( EXCEPTION_NAME , NULL, NULL);
+	Py_INCREF( yaospError );
+
+	PyModule_AddObject( module, "error", yaospError );
+}
diff -Nru Python-2.5.4-orig/Modules/config.c Python-2.5.4/Modules/config.c
--- Python-2.5.4-orig/Modules/config.c	1970-01-01 01:00:00.000000000 +0100
+++ Python-2.5.4/Modules/config.c	2009-04-20 20:15:38.000000000 +0200
@@ -0,0 +1,101 @@
+/* Generated automatically from ./Modules/config.c.in by makesetup. */
+/* -*- C -*- ***********************************************
+Copyright (c) 2000, BeOpen.com.
+Copyright (c) 1995-2000, Corporation for National Research Initiatives.
+Copyright (c) 1990-1995, Stichting Mathematisch Centrum.
+All rights reserved.
+
+See the file "Misc/COPYRIGHT" for information on usage and
+redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+******************************************************************/
+
+/* Module configuration */
+
+/* !!! !!! !!! This file is edited by the makesetup script !!! !!! !!! */
+
+/* This file contains the table of built-in modules.
+   See init_builtin() in import.c. */
+
+#include "Python.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+extern void initthread(void);
+extern void initsignal(void);
+extern void initposix(void);
+extern void initerrno(void);
+extern void initpwd(void);
+extern void init_sre(void);
+extern void init_codecs(void);
+extern void initzipimport(void);
+extern void init_symtable(void);
+extern void initxxsubtype(void);
+extern void initreadline(void);
+extern void inityaosp(void);
+extern void init_curses(void);
+extern void inittime(void );
+extern void init_struct(void);
+extern void initbz2(void);
+
+/* -- ADDMODULE MARKER 1 -- */
+
+extern void PyMarshal_Init(void);
+extern void initimp(void);
+extern void initgc(void);
+extern void init_ast(void);
+extern void init_types(void);
+
+struct _inittab _PyImport_Inittab[] = {
+
+  {"_yaosp", inityaosp },
+  {"_curses", init_curses },
+  {"time", inittime },
+  {"_struct", init_struct },
+  {"bz2", initbz2 },
+//  {"thread", initthread},
+//  {"signal", initsignal},
+  {"posix", initposix},
+  {"errno", initerrno},
+//  {"pwd", initpwd},
+  {"_sre", init_sre},
+  {"_codecs", init_codecs},
+  {"zipimport", initzipimport},
+  {"_symtable", init_symtable},
+//  {"xxsubtype", initxxsubtype},
+  {"readline", initreadline},
+
+/* -- ADDMODULE MARKER 2 -- */
+
+  /* This module lives in marshal.c */
+  {"marshal", PyMarshal_Init},
+
+  /* This lives in import.c */
+  {"imp", initimp},
+
+  /* This lives in Python/Python-ast.c */
+  {"_ast", init_ast},
+
+  /* This lives in Python/_types.c */
+  {"_types", init_types},
+
+  /* These entries are here for sys.builtin_module_names */
+  {"__main__", NULL},
+  {"__builtin__", NULL},
+  {"sys", NULL},
+  {"exceptions", NULL},
+
+  /* This lives in gcmodule.c */
+  {"gc", initgc},
+
+  /* Sentinel */
+  {0, 0}
+};
+
+
+#ifdef __cplusplus
+}
+#endif
+
diff -Nru Python-2.5.4-orig/Modules/getpath.c Python-2.5.4/Modules/getpath.c
--- Python-2.5.4-orig/Modules/getpath.c	2006-07-10 03:18:57.000000000 +0200
+++ Python-2.5.4/Modules/getpath.c	2009-04-20 20:15:38.000000000 +0200
@@ -6,102 +6,12 @@
 #include <sys/types.h>
 #include <string.h>
 
-#ifdef __APPLE__
-#include <mach-o/dyld.h>
-#endif
-
-/* Search in some common locations for the associated Python libraries.
- *
- * Two directories must be found, the platform independent directory
- * (prefix), containing the common .py and .pyc files, and the platform
- * dependent directory (exec_prefix), containing the shared library
- * modules.  Note that prefix and exec_prefix can be the same directory,
- * but for some installations, they are different.
- *
- * Py_GetPath() carries out separate searches for prefix and exec_prefix.
- * Each search tries a number of different locations until a ``landmark''
- * file or directory is found.  If no prefix or exec_prefix is found, a
- * warning message is issued and the preprocessor defined PREFIX and
- * EXEC_PREFIX are used (even though they will not work); python carries on
- * as best as is possible, but most imports will fail.
- *
- * Before any searches are done, the location of the executable is
- * determined.  If argv[0] has one or more slashs in it, it is used
- * unchanged.  Otherwise, it must have been invoked from the shell's path,
- * so we search $PATH for the named executable and use that.  If the
- * executable was not found on $PATH (or there was no $PATH environment
- * variable), the original argv[0] string is used.
- *
- * Next, the executable location is examined to see if it is a symbolic
- * link.  If so, the link is chased (correctly interpreting a relative
- * pathname if one is found) and the directory of the link target is used.
- *
- * Finally, argv0_path is set to the directory containing the executable
- * (i.e. the last component is stripped).
- *
- * With argv0_path in hand, we perform a number of steps.  The same steps
- * are performed for prefix and for exec_prefix, but with a different
- * landmark.
- *
- * Step 1. Are we running python out of the build directory?  This is
- * checked by looking for a different kind of landmark relative to
- * argv0_path.  For prefix, the landmark's path is derived from the VPATH
- * preprocessor variable (taking into account that its value is almost, but
- * not quite, what we need).  For exec_prefix, the landmark is
- * Modules/Setup.  If the landmark is found, we're done.
- *
- * For the remaining steps, the prefix landmark will always be
- * lib/python$VERSION/os.py and the exec_prefix will always be
- * lib/python$VERSION/lib-dynload, where $VERSION is Python's version
- * number as supplied by the Makefile.  Note that this means that no more
- * build directory checking is performed; if the first step did not find
- * the landmarks, the assumption is that python is running from an
- * installed setup.
- *
- * Step 2. See if the $PYTHONHOME environment variable points to the
- * installed location of the Python libraries.  If $PYTHONHOME is set, then
- * it points to prefix and exec_prefix.  $PYTHONHOME can be a single
- * directory, which is used for both, or the prefix and exec_prefix
- * directories separated by a colon.
- *
- * Step 3. Try to find prefix and exec_prefix relative to argv0_path,
- * backtracking up the path until it is exhausted.  This is the most common
- * step to succeed.  Note that if prefix and exec_prefix are different,
- * exec_prefix is more likely to be found; however if exec_prefix is a
- * subdirectory of prefix, both will be found.
- *
- * Step 4. Search the directories pointed to by the preprocessor variables
- * PREFIX and EXEC_PREFIX.  These are supplied by the Makefile but can be
- * passed in as options to the configure script.
- *
- * That's it!
- *
- * Well, almost.  Once we have determined prefix and exec_prefix, the
- * preprocessor variable PYTHONPATH is used to construct a path.  Each
- * relative path on PYTHONPATH is prefixed with prefix.  Then the directory
- * containing the shared library modules is appended.  The environment
- * variable $PYTHONPATH is inserted in front of it all.  Finally, the
- * prefix and exec_prefix globals are tweaked so they reflect the values
- * expected by other code, by stripping the "lib/python$VERSION/..." stuff
- * off.  If either points to the build directory, the globals are reset to
- * the corresponding preprocessor variables (so sys.prefix will reflect the
- * installation location, even though sys.path points into the build
- * directory).  This seems to make more sense given that currently the only
- * known use of sys.prefix and sys.exec_prefix is for the ILU installation
- * process to find the installed Python tree.
- */
-
 #ifdef __cplusplus
  extern "C" {
 #endif
 
-
 #ifndef VERSION
-#define VERSION "2.1"
-#endif
-
-#ifndef VPATH
-#define VPATH "."
+#define VERSION "2.2"
 #endif
 
 #ifndef PREFIX
@@ -121,53 +31,10 @@
               EXEC_PREFIX "/lib/python" VERSION "/lib-dynload"
 #endif
 
-#ifndef LANDMARK
-#define LANDMARK "os.py"
-#endif
-
 static char prefix[MAXPATHLEN+1];
 static char exec_prefix[MAXPATHLEN+1];
 static char progpath[MAXPATHLEN+1];
 static char *module_search_path = NULL;
-static char lib_python[] = "lib/python" VERSION;
-
-static void
-reduce(char *dir)
-{
-    size_t i = strlen(dir);
-    while (i > 0 && dir[i] != SEP)
-        --i;
-    dir[i] = '\0';
-}
-
-
-static int
-isfile(char *filename)          /* Is file, not directory */
-{
-    struct stat buf;
-    if (stat(filename, &buf) != 0)
-        return 0;
-    if (!S_ISREG(buf.st_mode))
-        return 0;
-    return 1;
-}
-
-
-static int
-ismodule(char *filename)        /* Is module -- check for .pyc/.pyo too */
-{
-    if (isfile(filename))
-        return 1;
-
-    /* Check for the compiled version of prefix. */
-    if (strlen(filename) < MAXPATHLEN) {
-        strcat(filename, Py_OptimizeFlag ? "o" : "c");
-        if (isfile(filename))
-            return 1;
-    }
-    return 0;
-}
-
 
 static int
 isxfile(char *filename)         /* Is executable file */
@@ -177,20 +44,8 @@
         return 0;
     if (!S_ISREG(buf.st_mode))
         return 0;
-    if ((buf.st_mode & 0111) == 0)
-        return 0;
-    return 1;
-}
-
-
-static int
-isdir(char *filename)                   /* Is directory */
-{
-    struct stat buf;
-    if (stat(filename, &buf) != 0)
-        return 0;
-    if (!S_ISDIR(buf.st_mode))
-        return 0;
+    //if ((buf.st_mode & 0111) == 0) // TODO not implemented yet
+    //   return 0;
     return 1;
 }
 
@@ -251,169 +106,26 @@
     strcpy(path, buffer);
 }
 
-/* search_for_prefix requires that argv0_path be no more than MAXPATHLEN
-   bytes long.
-*/
-static int
-search_for_prefix(char *argv0_path, char *home)
-{
-    size_t n;
-    char *vpath;
-
-    /* If PYTHONHOME is set, we believe it unconditionally */
-    if (home) {
-        char *delim;
-        strncpy(prefix, home, MAXPATHLEN);
-        delim = strchr(prefix, DELIM);
-        if (delim)
-            *delim = '\0';
-        joinpath(prefix, lib_python);
-        joinpath(prefix, LANDMARK);
-        return 1;
-    }
-
-    /* Check to see if argv[0] is in the build directory */
-    strcpy(prefix, argv0_path);
-    joinpath(prefix, "Modules/Setup");
-    if (isfile(prefix)) {
-        /* Check VPATH to see if argv0_path is in the build directory. */
-        vpath = VPATH;
-        strcpy(prefix, argv0_path);
-        joinpath(prefix, vpath);
-        joinpath(prefix, "Lib");
-        joinpath(prefix, LANDMARK);
-        if (ismodule(prefix))
-            return -1;
-    }
-
-    /* Search from argv0_path, until root is found */
-    copy_absolute(prefix, argv0_path);
-    do {
-        n = strlen(prefix);
-        joinpath(prefix, lib_python);
-        joinpath(prefix, LANDMARK);
-        if (ismodule(prefix))
-            return 1;
-        prefix[n] = '\0';
-        reduce(prefix);
-    } while (prefix[0]);
-
-    /* Look at configure's PREFIX */
-    strncpy(prefix, PREFIX, MAXPATHLEN);
-    joinpath(prefix, lib_python);
-    joinpath(prefix, LANDMARK);
-    if (ismodule(prefix))
-        return 1;
-
-    /* Fail */
-    return 0;
-}
-
-
-/* search_for_exec_prefix requires that argv0_path be no more than
-   MAXPATHLEN bytes long.
-*/
-static int
-search_for_exec_prefix(char *argv0_path, char *home)
-{
-    size_t n;
-
-    /* If PYTHONHOME is set, we believe it unconditionally */
-    if (home) {
-        char *delim;
-        delim = strchr(home, DELIM);
-        if (delim)
-            strncpy(exec_prefix, delim+1, MAXPATHLEN);
-        else
-            strncpy(exec_prefix, home, MAXPATHLEN);
-        joinpath(exec_prefix, lib_python);
-        joinpath(exec_prefix, "lib-dynload");
-        return 1;
-    }
-
-    /* Check to see if argv[0] is in the build directory */
-    strcpy(exec_prefix, argv0_path);
-    joinpath(exec_prefix, "Modules/Setup");
-    if (isfile(exec_prefix)) {
-        reduce(exec_prefix);
-        return -1;
-    }
-
-    /* Search from argv0_path, until root is found */
-    copy_absolute(exec_prefix, argv0_path);
-    do {
-        n = strlen(exec_prefix);
-        joinpath(exec_prefix, lib_python);
-        joinpath(exec_prefix, "lib-dynload");
-        if (isdir(exec_prefix))
-            return 1;
-        exec_prefix[n] = '\0';
-        reduce(exec_prefix);
-    } while (exec_prefix[0]);
-
-    /* Look at configure's EXEC_PREFIX */
-    strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
-    joinpath(exec_prefix, lib_python);
-    joinpath(exec_prefix, "lib-dynload");
-    if (isdir(exec_prefix))
-        return 1;
-
-    /* Fail */
-    return 0;
-}
-
 
-static void
-calculate_path(void)
+static void calculate_path(void)
 {
-    extern char *Py_GetProgramName(void);
+	extern char *Py_GetProgramName(void);
 
-    static char delimiter[2] = {DELIM, '\0'};
-    static char separator[2] = {SEP, '\0'};
-    char *pythonpath = PYTHONPATH;
-    char *rtpypath = Py_GETENV("PYTHONPATH");
-    char *home = Py_GetPythonHome();
-    char *path = getenv("PATH");
-    char *prog = Py_GetProgramName();
-    char argv0_path[MAXPATHLEN+1];
-    char zip_path[MAXPATHLEN+1];
-    int pfound, efound; /* 1 if found; -1 if found build directory */
-    char *buf;
-    size_t bufsz;
-    size_t prefixsz;
-    char *defpath = pythonpath;
-#ifdef WITH_NEXT_FRAMEWORK
-    NSModule pythonModule;
-#endif
-#ifdef __APPLE__
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
-    uint32_t nsexeclength = MAXPATHLEN;
-#else
-    unsigned long nsexeclength = MAXPATHLEN;
-#endif
-#endif
+	char *path = getenv("PATH");
+	char *prog = Py_GetProgramName();
 
+	strncpy(prefix, PREFIX, MAXPATHLEN);
+	strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+	module_search_path = PYTHONPATH;
+	
 	/* If there is no slash in the argv0 path, then we have to
 	 * assume python is on the user's $PATH, since there's no
 	 * other way to find a directory to start the search from.  If
 	 * $PATH isn't exported, you lose.
 	 */
-	if (strchr(prog, SEP))
-		strncpy(progpath, prog, MAXPATHLEN);
-#ifdef __APPLE__
-     /* On Mac OS X, if a script uses an interpreter of the form
-      * "#!/opt/python2.3/bin/python", the kernel only passes "python"
-      * as argv[0], which falls through to the $PATH search below.
-      * If /opt/python2.3/bin isn't in your path, or is near the end,
-      * this algorithm may incorrectly find /usr/bin/python. To work
-      * around this, we can use _NSGetExecutablePath to get a better
-      * hint of what the intended interpreter was, although this
-      * will fail if a relative path was used. but in that case,
-      * absolutize() should help us out below
-      */
-     else if(0 == _NSGetExecutablePath(progpath, &nsexeclength) && progpath[0] == SEP)
-       ;
-#endif /* __APPLE__ */
+	if (strchr(prog, SEP)) {		
+		strncpy(progpath, prog, MAXPATHLEN);		
+	}
 	else if (path) {
 		while (1) {
 			char *delim = strchr(path, DELIM);
@@ -421,7 +133,7 @@
 			if (delim) {
 				size_t len = delim - path;
 				if (len > MAXPATHLEN)
-					len = MAXPATHLEN;
+					len = MAXPATHLEN;				
 				strncpy(progpath, path, len);
 				*(progpath + len) = '\0';
 			}
@@ -443,213 +155,6 @@
 		progpath[0] = '\0';
 	if (progpath[0] != SEP)
 		absolutize(progpath);
-	strncpy(argv0_path, progpath, MAXPATHLEN);
-	argv0_path[MAXPATHLEN] = '\0';
-
-#ifdef WITH_NEXT_FRAMEWORK
-	/* On Mac OS X we have a special case if we're running from a framework.
-	** This is because the python home should be set relative to the library,
-	** which is in the framework, not relative to the executable, which may
-	** be outside of the framework. Except when we're in the build directory...
-	*/
-    pythonModule = NSModuleForSymbol(NSLookupAndBindSymbol("_Py_Initialize"));
-    /* Use dylib functions to find out where the framework was loaded from */
-    buf = (char *)NSLibraryNameForModule(pythonModule);
-    if (buf != NULL) {
-        /* We're in a framework. */
-        /* See if we might be in the build directory. The framework in the
-        ** build directory is incomplete, it only has the .dylib and a few
-        ** needed symlinks, it doesn't have the Lib directories and such.
-        ** If we're running with the framework from the build directory we must
-        ** be running the interpreter in the build directory, so we use the
-        ** build-directory-specific logic to find Lib and such.
-        */
-        strncpy(argv0_path, buf, MAXPATHLEN);
-        reduce(argv0_path);
-        joinpath(argv0_path, lib_python);
-        joinpath(argv0_path, LANDMARK);
-        if (!ismodule(argv0_path)) {
-                /* We are in the build directory so use the name of the
-                   executable - we know that the absolute path is passed */
-                strncpy(argv0_path, prog, MAXPATHLEN);
-        }
-        else {
-                /* Use the location of the library as the progpath */
-                strncpy(argv0_path, buf, MAXPATHLEN);
-        }
-    }
-#endif
-
-#if HAVE_READLINK
-    {
-        char tmpbuffer[MAXPATHLEN+1];
-        int linklen = readlink(progpath, tmpbuffer, MAXPATHLEN);
-        while (linklen != -1) {
-            /* It's not null terminated! */
-            tmpbuffer[linklen] = '\0';
-            if (tmpbuffer[0] == SEP)
-                /* tmpbuffer should never be longer than MAXPATHLEN,
-                   but extra check does not hurt */
-                strncpy(argv0_path, tmpbuffer, MAXPATHLEN);
-            else {
-                /* Interpret relative to progpath */
-                reduce(argv0_path);
-                joinpath(argv0_path, tmpbuffer);
-            }
-            linklen = readlink(argv0_path, tmpbuffer, MAXPATHLEN);
-        }
-    }
-#endif /* HAVE_READLINK */
-
-    reduce(argv0_path);
-    /* At this point, argv0_path is guaranteed to be less than
-       MAXPATHLEN bytes long.
-    */
-
-    if (!(pfound = search_for_prefix(argv0_path, home))) {
-        if (!Py_FrozenFlag)
-            fprintf(stderr,
-                "Could not find platform independent libraries <prefix>\n");
-        strncpy(prefix, PREFIX, MAXPATHLEN);
-        joinpath(prefix, lib_python);
-    }
-    else
-        reduce(prefix);
-
-    strncpy(zip_path, prefix, MAXPATHLEN);
-    zip_path[MAXPATHLEN] = '\0';
-    if (pfound > 0) { /* Use the reduced prefix returned by Py_GetPrefix() */
-        reduce(zip_path);
-        reduce(zip_path);
-    }
-    else
-        strncpy(zip_path, PREFIX, MAXPATHLEN);
-    joinpath(zip_path, "lib/python00.zip");
-    bufsz = strlen(zip_path);	/* Replace "00" with version */
-    zip_path[bufsz - 6] = VERSION[0];
-    zip_path[bufsz - 5] = VERSION[2];
-
-    if (!(efound = search_for_exec_prefix(argv0_path, home))) {
-        if (!Py_FrozenFlag)
-            fprintf(stderr,
-                "Could not find platform dependent libraries <exec_prefix>\n");
-        strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
-        joinpath(exec_prefix, "lib/lib-dynload");
-    }
-    /* If we found EXEC_PREFIX do *not* reduce it!  (Yet.) */
-
-    if ((!pfound || !efound) && !Py_FrozenFlag)
-        fprintf(stderr,
-                "Consider setting $PYTHONHOME to <prefix>[:<exec_prefix>]\n");
-
-    /* Calculate size of return buffer.
-     */
-    bufsz = 0;
-
-    if (rtpypath)
-        bufsz += strlen(rtpypath) + 1;
-
-    prefixsz = strlen(prefix) + 1;
-
-    while (1) {
-        char *delim = strchr(defpath, DELIM);
-
-        if (defpath[0] != SEP)
-            /* Paths are relative to prefix */
-            bufsz += prefixsz;
-
-        if (delim)
-            bufsz += delim - defpath + 1;
-        else {
-            bufsz += strlen(defpath) + 1;
-            break;
-        }
-        defpath = delim + 1;
-    }
-
-    bufsz += strlen(zip_path) + 1;
-    bufsz += strlen(exec_prefix) + 1;
-
-    /* This is the only malloc call in this file */
-    buf = (char *)PyMem_Malloc(bufsz);
-
-    if (buf == NULL) {
-        /* We can't exit, so print a warning and limp along */
-        fprintf(stderr, "Not enough memory for dynamic PYTHONPATH.\n");
-        fprintf(stderr, "Using default static PYTHONPATH.\n");
-        module_search_path = PYTHONPATH;
-    }
-    else {
-        /* Run-time value of $PYTHONPATH goes first */
-        if (rtpypath) {
-            strcpy(buf, rtpypath);
-            strcat(buf, delimiter);
-        }
-        else
-            buf[0] = '\0';
-
-        /* Next is the default zip path */
-        strcat(buf, zip_path);
-        strcat(buf, delimiter);
-
-        /* Next goes merge of compile-time $PYTHONPATH with
-         * dynamically located prefix.
-         */
-        defpath = pythonpath;
-        while (1) {
-            char *delim = strchr(defpath, DELIM);
-
-            if (defpath[0] != SEP) {
-                strcat(buf, prefix);
-                strcat(buf, separator);
-            }
-
-            if (delim) {
-                size_t len = delim - defpath + 1;
-                size_t end = strlen(buf) + len;
-                strncat(buf, defpath, len);
-                *(buf + end) = '\0';
-            }
-            else {
-                strcat(buf, defpath);
-                break;
-            }
-            defpath = delim + 1;
-        }
-        strcat(buf, delimiter);
-
-        /* Finally, on goes the directory for dynamic-load modules */
-        strcat(buf, exec_prefix);
-
-        /* And publish the results */
-        module_search_path = buf;
-    }
-
-    /* Reduce prefix and exec_prefix to their essence,
-     * e.g. /usr/local/lib/python1.5 is reduced to /usr/local.
-     * If we're loading relative to the build directory,
-     * return the compiled-in defaults instead.
-     */
-    if (pfound > 0) {
-        reduce(prefix);
-        reduce(prefix);
-	/* The prefix is the root directory, but reduce() chopped
-	 * off the "/". */
-	if (!prefix[0])
-		strcpy(prefix, separator);
-    }
-    else
-        strncpy(prefix, PREFIX, MAXPATHLEN);
-
-    if (efound > 0) {
-        reduce(exec_prefix);
-        reduce(exec_prefix);
-        reduce(exec_prefix);
-	if (!exec_prefix[0])
-		strcpy(exec_prefix, separator);
-    }
-    else
-        strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
 }
 
 
diff -Nru Python-2.5.4-orig/Modules/posixmodule.c Python-2.5.4/Modules/posixmodule.c
--- Python-2.5.4-orig/Modules/posixmodule.c	2008-12-13 16:14:30.000000000 +0100
+++ Python-2.5.4/Modules/posixmodule.c	2009-04-20 20:29:11.000000000 +0200
@@ -15,7 +15,7 @@
 
 #ifdef __APPLE__
    /*
-    * Step 1 of support for weak-linking a number of symbols existing on 
+    * Step 1 of support for weak-linking a number of symbols existing on
     * OSX 10.4 and later, see the comment in the #ifdef __APPLE__ block
     * at the end of this file for more information.
     */
@@ -646,8 +646,8 @@
 
 #ifdef Py_WIN_WIDE_FILENAMES
 static PyObject*
-win32_1str(PyObject* args, char* func, 
-	   char* format, BOOL (__stdcall *funcA)(LPCSTR), 
+win32_1str(PyObject* args, char* func,
+	   char* format, BOOL (__stdcall *funcA)(LPCSTR),
 	   char* wformat, BOOL (__stdcall *funcW)(LPWSTR))
 {
 	PyObject *uni;
@@ -746,7 +746,7 @@
      UTC and local time
    Therefore, we implement our own stat, based on the Win32 API directly.
 */
-#define HAVE_STAT_NSEC 1 
+#define HAVE_STAT_NSEC 1
 
 struct win32_stat{
     int st_dev;
@@ -771,7 +771,7 @@
 FILE_TIME_to_time_t_nsec(FILETIME *in_ptr, int *time_out, int* nsec_out)
 {
 	/* XXX endianness. Shouldn't matter, as all Windows implementations are little-endian */
-	/* Cannot simply cast and dereference in_ptr, 
+	/* Cannot simply cast and dereference in_ptr,
 	   since it might not be aligned properly */
 	__int64 in;
 	memcpy(&in, in_ptr, sizeof(in));
@@ -875,7 +875,7 @@
 }
 
 static BOOL WINAPI
-Py_GetFileAttributesExA(LPCSTR pszFile, 
+Py_GetFileAttributesExA(LPCSTR pszFile,
 		       GET_FILEEX_INFO_LEVELS level,
                        LPVOID pv)
 {
@@ -905,7 +905,7 @@
 }
 
 static BOOL WINAPI
-Py_GetFileAttributesExW(LPCWSTR pszFile, 
+Py_GetFileAttributesExW(LPCWSTR pszFile,
 		       GET_FILEEX_INFO_LEVELS level,
                        LPVOID pv)
 {
@@ -934,7 +934,7 @@
 	return attributes_from_dir_w(pszFile, pfad);
 }
 
-static int 
+static int
 win32_stat(const char* path, struct win32_stat *result)
 {
 	WIN32_FILE_ATTRIBUTE_DATA info;
@@ -972,7 +972,7 @@
 	return code;
 }
 
-static int 
+static int
 win32_wstat(const wchar_t* path, struct win32_stat *result)
 {
 	int code;
@@ -1016,9 +1016,9 @@
 	BY_HANDLE_FILE_INFORMATION info;
 	HANDLE h;
 	int type;
-    
+
 	h = (HANDLE)_get_osfhandle(file_number);
-    
+
 	/* Protocol violation: we explicitly clear errno, instead of
 	   setting it to a POSIX error. Callers should use GetLastError. */
 	errno = 0;
@@ -1477,7 +1477,7 @@
 #else
 		result = posix_error_with_filename(pathfree);
 #endif
-	} 
+	}
 	else
 		result = _pystat_fromstructstat(&st);
 
@@ -1500,7 +1500,7 @@
 {
 	char *path;
 	int mode;
-	
+
 #ifdef Py_WIN_WIDE_FILENAMES
 	DWORD attr;
 	if (unicode_file_names()) {
@@ -1531,12 +1531,12 @@
 	/* Access is possible if either write access wasn't requested, or
 	   the file isn't read-only, or if it's a directory, as there are
 	   no read-only directories on Windows. */
-	return PyBool_FromLong(!(mode & 2) 
+	return PyBool_FromLong(!(mode & 2)
 	                       || !(attr & FILE_ATTRIBUTE_READONLY)
 			       || (attr & FILE_ATTRIBUTE_DIRECTORY));
 #else
 	int res;
-	if (!PyArg_ParseTuple(args, "eti:access", 
+	if (!PyArg_ParseTuple(args, "eti:access",
 			      Py_FileSystemDefaultEncoding, &path, &mode))
 		return NULL;
 	Py_BEGIN_ALLOW_THREADS
@@ -2218,7 +2218,7 @@
 		/* readdir() returned NULL and set errno */
 		closedir(dirp);
 		Py_DECREF(d);
-		return posix_error_with_allocated_filename(name); 
+		return posix_error_with_allocated_filename(name);
 	}
 	closedir(dirp);
 	PyMem_Free(name);
@@ -2457,6 +2457,7 @@
 }
 
 
+#undef HAVE_SYSTEM
 #ifdef HAVE_SYSTEM
 PyDoc_STRVAR(posix_system__doc__,
 "system(command) -> exit_status\n\n\
@@ -2476,6 +2477,29 @@
 }
 #endif
 
+PyDoc_STRVAR(posix_mount__doc__,
+    "mount(device,mnt_point,filesystem) -> return value\n");
+
+static PyObject *
+posix_mount(PyObject *self, PyObject *args)
+{
+    int error;
+    char* device;
+    char* mnt_point;
+    char* filesystem;
+
+    if ( !PyArg_ParseTuple( args, "sss", &device, &mnt_point, &filesystem ) ) {
+        return NULL;
+    }
+
+    error = mount( device, mnt_point, filesystem, 0, NULL );
+
+    if ( error < 0 ) {
+        return posix_error();
+    }
+
+    return PyInt_FromLong( ( long )error );
+}
 
 PyDoc_STRVAR(posix_umask__doc__,
 "umask(new_mask) -> old_mask\n\n\
@@ -2615,7 +2639,7 @@
 		}
 		PyMem_Free(apath);
 	}
-	
+
 	if (arg == Py_None) {
 		SYSTEMTIME now;
 		GetSystemTime(&now);
@@ -3583,6 +3607,7 @@
 }
 #endif
 
+#undef HAVE_GETEGID
 #ifdef HAVE_GETEGID
 PyDoc_STRVAR(posix_getegid__doc__,
 "getegid() -> egid\n\n\
@@ -3596,6 +3621,7 @@
 #endif
 
 
+#undef HAVE_GETEUID
 #ifdef HAVE_GETEUID
 PyDoc_STRVAR(posix_geteuid__doc__,
 "geteuid() -> euid\n\n\
@@ -3609,6 +3635,7 @@
 #endif
 
 
+#undef HAVE_GETGID
 #ifdef HAVE_GETGID
 PyDoc_STRVAR(posix_getgid__doc__,
 "getgid() -> gid\n\n\
@@ -3731,6 +3758,7 @@
 
 #endif /* HAVE_SETPGRP */
 
+#undef HAVE_GETPPID
 #ifdef HAVE_GETPPID
 PyDoc_STRVAR(posix_getppid__doc__,
 "getppid() -> ppid\n\n\
@@ -3773,6 +3801,7 @@
 }
 #endif
 
+#undef HAVE_GETUID
 #ifdef HAVE_GETUID
 PyDoc_STRVAR(posix_getuid__doc__,
 "getuid() -> uid\n\n\
@@ -3786,6 +3815,7 @@
 #endif
 
 
+#undef HAVE_KILL
 #ifdef HAVE_KILL
 PyDoc_STRVAR(posix_kill__doc__,
 "kill(pid, sig)\n\n\
@@ -3861,6 +3891,7 @@
 #endif
 
 
+#undef HAVE_POPEN
 #ifdef HAVE_POPEN
 PyDoc_STRVAR(posix_popen__doc__,
 "popen(command [, mode='r' [, bufsize]]) -> pipe\n\n\
@@ -5478,7 +5509,7 @@
 			} else {
 				unsigned long x = PyLong_AsUnsignedLong(elem);
 				if (PyErr_Occurred()) {
-					PyErr_SetString(PyExc_TypeError, 
+					PyErr_SetString(PyExc_TypeError,
 							"group id too big");
 					Py_DECREF(elem);
 					return NULL;
@@ -5669,6 +5700,7 @@
 }
 #endif /* HAVE_WAITPID || HAVE_CWAIT */
 
+#undef HAVE_WAIT
 #ifdef HAVE_WAIT
 PyDoc_STRVAR(posix_wait__doc__,
 "wait() -> (pid, status)\n\n\
@@ -6230,6 +6262,7 @@
 	return PyBool_FromLong(isatty(fd));
 }
 
+#undef HAVE_PIPE
 #ifdef HAVE_PIPE
 PyDoc_STRVAR(posix_pipe__doc__,
 "pipe() -> (read_end, write_end)\n\n\
@@ -7900,10 +7933,10 @@
 			PyErr_Clear();
 			goto normal;
 		}
-		
+
 
 		if (operation) {
-		    woperation = PyUnicode_DecodeASCII(operation, 
+		    woperation = PyUnicode_DecodeASCII(operation,
 						       strlen(operation), NULL);
 		    if (!woperation) {
 			    PyErr_Clear();
@@ -7911,7 +7944,7 @@
 			    goto normal;
 		    }
 		}
-			
+
 		Py_BEGIN_ALLOW_THREADS
 		rc = ShellExecuteW((HWND)0, woperation ? PyUnicode_AS_UNICODE(woperation) : 0,
 			PyUnicode_AS_UNICODE(unipath),
@@ -7930,12 +7963,12 @@
 #endif
 
 normal:
-	if (!PyArg_ParseTuple(args, "et|s:startfile", 
-			      Py_FileSystemDefaultEncoding, &filepath, 
+	if (!PyArg_ParseTuple(args, "et|s:startfile",
+			      Py_FileSystemDefaultEncoding, &filepath,
 			      &operation))
 		return NULL;
 	Py_BEGIN_ALLOW_THREADS
-	rc = ShellExecute((HWND)0, operation, filepath, 
+	rc = ShellExecute((HWND)0, operation, filepath,
 			  NULL, NULL, SW_SHOWNORMAL);
 	Py_END_ALLOW_THREADS
 	if (rc <= (HINSTANCE)32) {
@@ -8125,6 +8158,7 @@
 	{"system",	posix_system, METH_VARARGS, posix_system__doc__},
 #endif
 	{"umask",	posix_umask, METH_VARARGS, posix_umask__doc__},
+    {"mount",   posix_mount, METH_VARARGS, posix_mount__doc__},
 #ifdef HAVE_UNAME
 	{"uname",	posix_uname, METH_NOARGS, posix_uname__doc__},
 #endif /* HAVE_UNAME */
@@ -8727,10 +8761,10 @@
 	 * Step 2 of weak-linking support on Mac OS X.
 	 *
 	 * The code below removes functions that are not available on the
-	 * currently active platform. 
+	 * currently active platform.
 	 *
 	 * This block allow one to use a python binary that was build on
-	 * OSX 10.4 on OSX 10.3, without loosing access to new APIs on 
+	 * OSX 10.4 on OSX 10.3, without loosing access to new APIs on
 	 * OSX 10.4.
 	 */
 #ifdef HAVE_FSTATVFS
diff -Nru Python-2.5.4-orig/Python/getplatform.c Python-2.5.4/Python/getplatform.c
--- Python-2.5.4-orig/Python/getplatform.c	2000-09-02 01:29:29.000000000 +0200
+++ Python-2.5.4/Python/getplatform.c	2009-04-20 20:15:38.000000000 +0200
@@ -2,7 +2,7 @@
 #include "Python.h"
 
 #ifndef PLATFORM
-#define PLATFORM "unknown"
+#define PLATFORM "yaosp"
 #endif
 
 const char *
diff -Nru Python-2.5.4-orig/pbuild.xml Python-2.5.4/pbuild.xml
--- Python-2.5.4-orig/pbuild.xml	1970-01-01 01:00:00.000000000 +0100
+++ Python-2.5.4/pbuild.xml	2009-04-20 20:15:38.000000000 +0200
@@ -0,0 +1,231 @@
+<!--
+
+This file is part of the yaosp build system
+
+Copyright (c) 2009 Zoltan Kovacs
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of version 2 of the GNU General Public License
+as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+-->
+
+<build default="all">
+    <array name="files">
+        <item>Modules/_typesmodule.c</item>
+        <item>Modules/getbuildinfo.c</item>
+        <item>Modules/_yaospmodule.c</item>
+        <item>Parser/acceler.c</item>
+        <item>Parser/grammar1.c</item>
+        <item>Parser/listnode.c</item>
+        <item>Parser/node.c</item>
+        <item>Parser/parser.c</item>
+        <item>Parser/parsetok.c</item>
+        <item>Parser/bitset.c</item>
+        <item>Parser/metagrammar.c</item>
+        <item>Parser/firstsets.c</item>
+        <item>Parser/grammar.c</item>
+        <item>Parser/pgen.c</item>
+        <item>Parser/myreadline.c</item>
+        <item>Parser/tokenizer.c</item>
+        <item>Objects/abstract.c</item>
+        <item>Objects/boolobject.c</item>
+        <item>Objects/bufferobject.c</item>
+        <item>Objects/cellobject.c</item>
+        <item>Objects/classobject.c</item>
+        <item>Objects/cobject.c</item>
+        <item>Objects/codeobject.c</item>
+        <item>Objects/complexobject.c</item>
+        <item>Objects/descrobject.c</item>
+        <item>Objects/enumobject.c</item>
+        <item>Objects/exceptions.c</item>
+        <item>Objects/genobject.c</item>
+        <item>Objects/fileobject.c</item>
+        <item>Objects/floatobject.c</item>
+        <item>Objects/frameobject.c</item>
+        <item>Objects/funcobject.c</item>
+        <item>Objects/intobject.c</item>
+        <item>Objects/iterobject.c</item>
+        <item>Objects/listobject.c</item>
+        <item>Objects/longobject.c</item>
+        <item>Objects/dictobject.c</item>
+        <item>Objects/methodobject.c</item>
+        <item>Objects/moduleobject.c</item>
+        <item>Objects/object.c</item>
+        <item>Objects/obmalloc.c</item>
+        <item>Objects/rangeobject.c</item>
+        <item>Objects/setobject.c</item>
+        <item>Objects/sliceobject.c</item>
+        <item>Objects/stringobject.c</item>
+        <item>Objects/structseq.c</item>
+        <item>Objects/tupleobject.c</item>
+        <item>Objects/typeobject.c</item>
+        <item>Objects/weakrefobject.c</item>
+        <item>Objects/unicodeobject.c</item>
+        <item>Objects/unicodectype.c</item>
+        <item>Python/Python-ast.c</item>
+        <item>Python/asdl.c</item>
+        <item>Python/ast.c</item>
+        <item>Python/bltinmodule.c</item>
+        <item>Python/ceval.c</item>
+        <item>Python/compile.c</item>
+        <item>Python/codecs.c</item>
+        <item>Python/errors.c</item>
+        <item>Python/frozen.c</item>
+        <item>Python/frozenmain.c</item>
+        <item>Python/future.c</item>
+        <item>Python/getargs.c</item>
+        <item>Python/getcompiler.c</item>
+        <item>Python/getcopyright.c</item>
+        <item>Python/getmtime.c</item>
+        <item>Python/getplatform.c</item>
+        <item>Python/getversion.c</item>
+        <item>Python/graminit.c</item>
+        <item>Python/import.c</item>
+        <item>Python/importdl.c</item>
+        <item>Python/marshal.c</item>
+        <item>Python/modsupport.c</item>
+        <item>Python/mystrtoul.c</item>
+        <item>Python/mysnprintf.c</item>
+        <item>Python/pyarena.c</item>
+        <item>Python/pyfpe.c</item>
+        <item>Python/pystate.c</item>
+        <item>Python/pythonrun.c</item>
+        <item>Python/structmember.c</item>
+        <item>Python/symtable.c</item>
+        <item>Python/sysmodule.c</item>
+        <item>Python/traceback.c</item>
+        <item>Python/getopt.c</item>
+        <item>Python/pystrtod.c</item>
+        <item>Modules/config.c</item>
+        <item>Modules/getpath.c</item>
+        <item>Modules/main.c</item>
+        <item>Modules/gcmodule.c</item>
+        <item>Modules/errnomodule.c</item>
+        <item>Modules/_sre.c</item>
+        <item>Modules/_codecsmodule.c</item>
+        <item>Modules/zipimport.c</item>
+        <item>Modules/symtablemodule.c</item>
+        <item>Modules/posixmodule.c</item>
+        <item>Modules/python.c</item>
+        <item>Python/sigcheck.c</item>
+        <item>Parser/intrcheck.c</item>
+        <item>Modules/readline.c</item>
+        <item>Modules/_cursesmodule.c</item>
+        <item>Modules/timemodule.c</item>
+        <item>Modules/_struct.c</item>
+        <item>Modules/bz2module.c</item>
+    </array>
+
+    <array name="libs_to_install">
+        <item>site.py</item>
+        <item>os.py</item>
+        <item>copy_reg.py</item>
+        <item>posixpath.py</item>
+        <item>stat.py</item>
+        <item>types.py</item>
+        <item>yaosp.py</item>
+        <item>tarfile.py</item>
+        <item>shutil.py</item>
+        <item>struct.py</item>
+        <item>copy.py</item>
+        <item>curses/__init__.py</item>
+        <item>curses/ascii.py</item>
+        <item>curses/has_key.py</item>
+        <item>curses/panel.py</item>
+        <item>curses/textpad.py</item>
+        <item>curses/wrapper.py</item>
+    </array>
+
+    <target name="clean">
+        <delete>objs/*</delete>
+        <rmdir>objs</rmdir>
+    </target>
+
+    <target name="prepare" type="private">
+        <mkdir>objs</mkdir>
+    </target>
+
+    <target name="compile">
+        <call target="prepare"/>
+
+        <echo>Compiling Python 2.5.4</echo>
+
+        <for var="i" array="${files}">
+            <echo>-> ${i}</echo>
+            <gcc>
+                <input>${i}</input>
+                <output>objs/filename(${i}).o</output>
+                <include>../../../include</include>
+                <include>../../../../build/crosscompiler/lib/gcc/i686-pc-yaosp/4.3.3/include</include>
+                <include>./</include>
+                <include>./Include</include>
+                <flag>-c</flag>
+                <flag>-O2</flag>
+                <flag>-m32</flag>
+                <flag>-Wall</flag>
+                <flag>-nostdinc</flag>
+                <flag>-nostdlib</flag>
+                <flag>-fno-builtin</flag>
+                <flag>-fno-strict-aliasing</flag>
+                <define key="Py_BUILD_CORE"/>
+                <define key="PREFIX">"/yaosp/package"</define>
+                <define key="EXEC_PREFIX">"/yaosp/package"</define>
+                <define key="VERSION">"2.5.4"</define>
+                <define key="PYTHONPATH">"/yaosp/package/python-2.5.4/lib:/package/python-2.5.4/lib-dynload"</define>
+            </gcc>
+        </for>
+
+        <echo>Linking Python 2.5.4</echo>
+        <echo>-> objs/python</echo>
+
+        <gcc>
+            <input>objs/*.o</input>
+            <input>../../../lib/start/objs/libstart.a</input>
+            <input>../../../thirdparty/readline-6.0/readline-6.0/objs/libreadline.a</input>
+            <input>../../../thirdparty/ncurses-5.7/ncurses-5.7/objs/libncurses.a</input>
+            <input>../../../thirdparty/bzip2-1.0.5/bzip2-1.0.5/objs/libbzip2.a</input>
+            <input>../../../lib/c/objs/libc.a</input>
+            <output>objs/python</output>
+            <flag>-m32</flag>
+            <flag>-Xlinker</flag>
+            <flag>--script=../../../../scripts/i386_app.lnk</flag>
+            <flag>-nostartfiles</flag>
+            <flag>-nodefaultlibs</flag>
+        </gcc>
+    </target>
+
+    <target name="install">
+        <mkdir>../../../../build/image/package/python-2.5.4</mkdir>
+        <mkdir>../../../../build/image/package/python-2.5.4/lib</mkdir>
+        <mkdir>../../../../build/image/package/python-2.5.4/lib/curses</mkdir>
+        <mkdir>../../../../build/image/package/python-2.5.4/lib-dynload</mkdir>
+
+        <echo>Installing python binary</echo>
+
+        <copy from="objs/python" to="../../../../build/image/package/python-2.5.4/python"/>
+
+        <echo>Installing python libraries ...</echo>
+
+        <for var="i" array="${libs_to_install}">
+            <echo>-> ${i}</echo>
+
+            <copy from="Lib/${i}" to="../../../../build/image/package/python-2.5.4/lib/${i}"/>
+        </for>
+    </target>
+
+    <target name="all">
+        <call target="clean"/>
+        <call target="compile"/>
+        <call target="install"/>
+    </target>
+</build>
diff -Nru Python-2.5.4-orig/pyconfig.h Python-2.5.4/pyconfig.h
--- Python-2.5.4-orig/pyconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ Python-2.5.4/pyconfig.h	2009-04-20 20:15:38.000000000 +0200
@@ -0,0 +1,1001 @@
+/* pyconfig.h.  Generated from pyconfig.h.in by configure.  */
+/* pyconfig.h.in.  Generated from configure.in by autoheader.  */
+
+#ifndef Py_PYCONFIG_H
+#define Py_PYCONFIG_H
+
+/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want
+   support for AIX C++ shared extension modules. */
+/* #undef AIX_GENUINE_CPLUSPLUS */
+
+/* Define this if you have AtheOS threads. */
+/* #undef ATHEOS_THREADS */
+
+/* Define this if you have BeOS threads. */
+/* #undef BEOS_THREADS */
+
+/* Define if you have the Mach cthreads package */
+/* #undef C_THREADS */
+
+/* Define if --enable-ipv6 is specified */
+/* #undef ENABLE_IPV6 */
+
+/* Define if getpgrp() must be called as getpgrp(0). */
+/* #undef GETPGRP_HAVE_ARG */
+
+/* Define if gettimeofday() does not have second (timezone) argument This is
+   the case on Motorola V4 (R40V4.2) */
+/* #undef GETTIMEOFDAY_NO_TZ */
+
+/* struct addrinfo (netdb.h) */
+/* #undef HAVE_ADDRINFO */
+
+/* Define to 1 if you have the `alarm' function. */
+/* #undef HAVE_ALARM */
+
+/* Define this if your time.h defines altzone. */
+/* #undef HAVE_ALTZONE */
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+/* #undef HAVE_ASM_TYPES_H */
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+/* #undef HAVE_BIND_TEXTDOMAIN_CODESET */
+
+/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */
+/* #undef HAVE_BLUETOOTH_BLUETOOTH_H */
+
+/* Define to 1 if you have the <bluetooth.h> header file. */
+/* #undef HAVE_BLUETOOTH_H */
+
+/* Define if nice() returns success/failure instead of the new priority. */
+/* #undef HAVE_BROKEN_NICE */
+
+/* Define if poll() sets errno on invalid file descriptors. */
+/* #undef HAVE_BROKEN_POLL */
+
+/* Define if the Posix semaphores do not work on your system */
+/* #undef HAVE_BROKEN_POSIX_SEMAPHORES */
+
+/* Define if pthread_sigmask() does not work on your system. */
+/* #undef HAVE_BROKEN_PTHREAD_SIGMASK */
+
+/* Define to 1 if you have the `chown' function. */
+/* #undef HAVE_CHOWN */
+
+/* Define if you have the 'chroot' function. */
+/* #undef HAVE_CHROOT */
+
+/* Define to 1 if you have the `clock' function. */
+/* #undef HAVE_CLOCK */
+
+/* Define to 1 if you have the `confstr' function. */
+/* #undef HAVE_CONFSTR */
+
+/* Define to 1 if you have the <conio.h> header file. */
+/* #undef HAVE_CONIO_H */
+
+/* Define to 1 if you have the `ctermid' function. */
+/* #undef HAVE_CTERMID */
+
+/* Define if you have the 'ctermid_r' function. */
+/* #undef HAVE_CTERMID_R */
+
+/* Define to 1 if you have the <curses.h> header file. */
+/* #undef HAVE_CURSES_H 1 */
+
+/* Define if you have the 'is_term_resized' function. */
+/* #undef HAVE_CURSES_IS_TERM_RESIZED */
+
+/* Define if you have the 'resizeterm' function. */
+/* #undef HAVE_CURSES_RESIZETERM */
+
+/* Define if you have the 'resize_term' function. */
+/* #undef HAVE_CURSES_RESIZE_TERM */
+
+/* Define to 1 if you have the declaration of `tzname', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_TZNAME */
+
+/* Define to 1 if you have the device macros. */
+/* #undef HAVE_DEVICE_MACROS */
+
+/* Define if we have /dev/ptc. */
+/* #undef HAVE_DEV_PTC */
+
+/* Define if we have /dev/ptmx. */
+/* #undef HAVE_DEV_PTMX */
+
+/* Define to 1 if you have the <direct.h> header file. */
+/* #undef HAVE_DIRECT_H */
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+/* #undef HAVE_DLFCN_H */
+
+/* Define to 1 if you have the `dlopen' function. */
+/* #undef HAVE_DLOPEN */
+
+/* Define to 1 if you have the `dup2' function. */
+#define HAVE_DUP2 1
+
+/* Defined when any dynamic module loading is enabled. */
+/* #undef HAVE_DYNAMIC_LOADING */
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the `execv' function. */
+#define HAVE_EXECV 1
+
+/* Define if you have the 'fchdir' function. */
+#define HAVE_FCHDIR 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the 'fdatasync' function. */
+/* #undef HAVE_FDATASYNC */
+
+/* Define if you have the 'flock' function. */
+/* #undef HAVE_FLOCK */
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define to 1 if you have the `forkpty' function. */
+/* #undef HAVE_FORKPTY */
+
+/* Define to 1 if you have the `fpathconf' function. */
+/* #undef HAVE_FPATHCONF */
+
+/* Define to 1 if you have the `fseek64' function. */
+/* #undef HAVE_FSEEK64 */
+
+/* Define to 1 if you have the `fseeko' function. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `fstatvfs' function. */
+/* #undef HAVE_FSTATVFS */
+
+/* Define if you have the 'fsync' function. */
+/* #undef HAVE_FSYNC */
+
+/* Define to 1 if you have the `ftell64' function. */
+/* #undef HAVE_FTELL64 */
+
+/* Define to 1 if you have the `ftello' function. */
+#define HAVE_FTELLO 1
+
+/* Define to 1 if you have the `ftime' function. */
+/* #undef HAVE_FTIME */
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `gai_strerror' function. */
+/* #undef HAVE_GAI_STRERROR */
+
+/* Define if you have the getaddrinfo function. */
+/* #undef HAVE_GETADDRINFO */
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */
+/* #undef HAVE_GETC_UNLOCKED */
+
+/* Define to 1 if you have the `getgroups' function. */
+/* #undef HAVE_GETGROUPS */
+
+/* Define to 1 if you have the `gethostbyname' function. */
+/* #undef HAVE_GETHOSTBYNAME */
+
+/* Define this if you have some version of gethostbyname_r() */
+/* #undef HAVE_GETHOSTBYNAME_R */
+
+/* Define this if you have the 3-arg version of gethostbyname_r(). */
+/* #undef HAVE_GETHOSTBYNAME_R_3_ARG */
+
+/* Define this if you have the 5-arg version of gethostbyname_r(). */
+/* #undef HAVE_GETHOSTBYNAME_R_5_ARG */
+
+/* Define this if you have the 6-arg version of gethostbyname_r(). */
+/* #undef HAVE_GETHOSTBYNAME_R_6_ARG */
+
+/* Define to 1 if you have the `getloadavg' function. */
+/* #undef HAVE_GETLOADAVG */
+
+/* Define to 1 if you have the `getlogin' function. */
+/* #undef HAVE_GETLOGIN */
+
+/* Define to 1 if you have the `getnameinfo' function. */
+/* #undef HAVE_GETNAMEINFO */
+
+/* Define if you have the 'getpagesize' function. */
+#define HAVE_GETPAGESIZE 1
+
+/* Define to 1 if you have the `getpeername' function. */
+/* #undef HAVE_GETPEERNAME */
+
+/* Define to 1 if you have the `getpgid' function. */
+/* #undef HAVE_GETPGID */
+
+/* Define to 1 if you have the `getpgrp' function. */
+/* #undef HAVE_GETPGRP */
+
+/* Define to 1 if you have the `getpid' function. */
+#define HAVE_GETPID 1
+
+/* Define to 1 if you have the `getpriority' function. */
+/* #undef HAVE_GETPRIORITY */
+
+/* Define to 1 if you have the `getpwent' function. */
+/* #undef HAVE_GETPWENT */
+
+/* Define to 1 if you have the `getsid' function. */
+/* #undef HAVE_GETSID */
+
+/* Define to 1 if you have the `getspent' function. */
+/* #undef HAVE_GETSPENT */
+
+/* Define to 1 if you have the `getspnam' function. */
+/* #undef HAVE_GETSPNAM */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `getwd' function. */
+/* #undef HAVE_GETWD */
+
+/* Define to 1 if you have the <grp.h> header file. */
+/* #undef HAVE_GRP_H */
+
+/* Define if you have the 'hstrerror' function. */
+/* #undef HAVE_HSTRERROR */
+
+/* Define to 1 if you have the `hypot' function. */
+#define HAVE_HYPOT 1
+
+/* Define if you have the 'inet_aton' function. */
+/* #undef HAVE_INET_ATON */
+
+/* Define if you have the 'inet_pton' function. */
+/* #undef HAVE_INET_PTON */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <io.h> header file. */
+/* #undef HAVE_IO_H */
+
+/* Define to 1 if you have the `kill' function. */
+/* #undef HAVE_KILL */
+
+/* Define to 1 if you have the `killpg' function. */
+/* #undef HAVE_KILLPG */
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+/* #undef HAVE_LANGINFO_H */
+
+/* Defined to enable large file support when an off_t is bigger than a long
+   and long long is available and at least as big as an off_t. You may need to
+   add some flags for configuration and compilation to enable this mode. (For
+   Solaris and Linux, the necessary defines are already defined.) */
+/* #undef HAVE_LARGEFILE_SUPPORT */
+
+/* Define to 1 if you have the `lchown' function. */
+/* #undef HAVE_LCHOWN */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+/* #undef HAVE_LIBDL */
+
+/* Define to 1 if you have the `dld' library (-ldld). */
+/* #undef HAVE_LIBDLD */
+
+/* Define to 1 if you have the `ieee' library (-lieee). */
+/* #undef HAVE_LIBIEEE */
+
+/* Define to 1 if you have the <libintl.h> header file. */
+/* #undef HAVE_LIBINTL_H */
+
+/* Define to 1 if you have the `readline' library (-lreadline). */
+/* #undef HAVE_LIBREADLINE */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+/* #undef HAVE_LIBRESOLV */
+
+/* Define to 1 if you have the <libutil.h> header file. */
+/* #undef HAVE_LIBUTIL_H */
+
+/* Define if you have the 'link' function. */
+/* #undef HAVE_LINK */
+
+/* Define to 1 if you have the <linux/netlink.h> header file. */
+/* #undef HAVE_LINUX_NETLINK_H */
+
+/* Define this if you have the type long long. */
+#define HAVE_LONG_LONG 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define HAVE_LSTAT 1
+
+/* Define this if you have the makedev macro. */
+/* #undef HAVE_MAKEDEV */
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+/* #undef HAVE_MEMORY_H */
+
+/* Define to 1 if you have the `mkfifo' function. */
+/* #undef HAVE_MKFIFO */
+
+/* Define to 1 if you have the `mknod' function. */
+/* #undef HAVE_MKNOD */
+
+/* Define to 1 if you have the `mktime' function. */
+#define HAVE_MKTIME 1
+
+/* Define to 1 if you have the `mremap' function. */
+/* #undef HAVE_MREMAP */
+
+/* Define to 1 if you have the <ncurses.h> header file. */
+#define HAVE_NCURSES_H 1
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <netpacket/packet.h> header file. */
+/* #undef HAVE_NETPACKET_PACKET_H */
+
+/* Define to 1 if you have the `nice' function. */
+/* #undef HAVE_NICE */
+
+/* Define to 1 if you have the `openpty' function. */
+/* #undef HAVE_OPENPTY */
+
+/* Define is the (unsupported) OSADebug API's are present. */
+/* #undef HAVE_OSA_DEBUG */
+
+/* Define to 1 if you have the `pathconf' function. */
+/* #undef HAVE_PATHCONF */
+
+/* Define to 1 if you have the `pause' function. */
+/* #undef HAVE_PAUSE */
+
+/* Define to 1 if you have the `plock' function. */
+/* #undef HAVE_PLOCK */
+
+/* Define to 1 if you have the `poll' function. */
+/* #undef HAVE_POLL */
+
+/* Define to 1 if you have the <poll.h> header file. */
+/* #undef HAVE_POLL_H */
+
+/* Define to 1 if you have the <process.h> header file. */
+/* #undef HAVE_PROCESS_H */
+
+/* Define if your compiler supports function prototype */
+#define HAVE_PROTOTYPES 1
+
+/* Define if you have GNU PTH threads. */
+/* #undef HAVE_PTH */
+
+/* Defined for Solaris 2.6 bug in pthread header. */
+/* #undef HAVE_PTHREAD_DESTRUCTOR */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+/* #undef HAVE_PTHREAD_H */
+
+/* Define to 1 if you have the `pthread_init' function. */
+/* #undef HAVE_PTHREAD_INIT */
+
+/* Define to 1 if you have the `pthread_sigmask' function. */
+/* #undef HAVE_PTHREAD_SIGMASK */
+
+/* Define to 1 if you have the <pty.h> header file. */
+/* #undef HAVE_PTY_H */
+
+/* Define to 1 if you have the `putenv' function. */
+/* #undef HAVE_PUTENV */
+
+/* Define to 1 if you have the `readlink' function. */
+#define HAVE_READLINK 1
+
+/* Define to 1 if you have the `realpath' function. */
+/* #undef HAVE_REALPATH */
+
+/* Define if you have readline 2.1 */
+/* #undef HAVE_RL_CALLBACK */
+
+/* Define if you can turn off readline's signal handling. */
+/* #undef HAVE_RL_CATCH_SIGNAL */
+
+/* Define if you have readline 2.2 */
+/* #undef HAVE_RL_COMPLETION_APPEND_CHARACTER */
+
+/* Define if you have readline 4.2 */
+/* #undef HAVE_RL_COMPLETION_MATCHES */
+
+/* Define if you have readline 4.0 */
+/* #undef HAVE_RL_PRE_INPUT_HOOK */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have the `setegid' function. */
+/* #undef HAVE_SETEGID */
+
+/* Define to 1 if you have the `seteuid' function. */
+/* #undef HAVE_SETEUID */
+
+/* Define to 1 if you have the `setgid' function. */
+/* #undef HAVE_SETGID */
+
+/* Define if you have the 'setgroups' function. */
+/* #undef HAVE_SETGROUPS */
+
+/* Define to 1 if you have the `setlocale' function. */
+/* #undef HAVE_SETLOCALE */
+
+/* Define to 1 if you have the `setpgid' function. */
+/* #undef HAVE_SETPGID */
+
+/* Define to 1 if you have the `setpgrp' function. */
+/* #undef HAVE_SETPGRP */
+
+/* Define to 1 if you have the `setregid' function. */
+/* #undef HAVE_SETREGID */
+
+/* Define to 1 if you have the `setreuid' function. */
+/* #undef HAVE_SETREUID */
+
+/* Define to 1 if you have the `setsid' function. */
+/* #undef HAVE_SETSID */
+
+/* Define to 1 if you have the `setuid' function. */
+/* #undef HAVE_SETUID */
+
+/* Define to 1 if you have the `setvbuf' function. */
+#define HAVE_SETVBUF 1
+
+/* Define to 1 if you have the <shadow.h> header file. */
+/* #undef HAVE_SHADOW_H */
+
+/* Define to 1 if you have the `sigaction' function. */
+/* #undef HAVE_SIGACTION */
+
+/* Define to 1 if you have the `siginterrupt' function. */
+/* #undef HAVE_SIGINTERRUPT */
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the `sigrelse' function. */
+/* #undef HAVE_SIGRELSE */
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define if sockaddr has sa_len member */
+/* #undef HAVE_SOCKADDR_SA_LEN */
+
+/* struct sockaddr_storage (sys/socket.h) */
+/* #undef HAVE_SOCKADDR_STORAGE */
+
+/* Define if you have the 'socketpair' function. */
+/* #undef HAVE_SOCKETPAIR */
+
+/* Define if your compiler provides ssize_t */
+#define HAVE_SSIZE_T 1
+
+/* Define to 1 if you have the `statvfs' function. */
+/* #undef HAVE_STATVFS */
+
+/* Define if you have struct stat.st_mtim.tv_nsec */
+/* #undef HAVE_STAT_TV_NSEC */
+
+/* Define if you have struct stat.st_mtimensec */
+/* #undef HAVE_STAT_TV_NSEC2 */
+
+/* Define if your compiler supports variable length function prototypes (e.g.
+   void fprintf(FILE *, char *, ...);) *and* <stdarg.h> */
+#define HAVE_STDARG_PROTOTYPES 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `strftime' function. */
+#define HAVE_STRFTIME 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+/* #undef HAVE_STRINGS_H */
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <stropts.h> header file. */
+/* #undef HAVE_STROPTS_H */
+
+/* Define to 1 if `st_birthtime' is member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */
+
+/* Define to 1 if `st_blksize' is member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_BLKSIZE 1
+
+/* Define to 1 if `st_blocks' is member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_BLOCKS 1
+
+/* Define to 1 if `st_flags' is member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_FLAGS */
+
+/* Define to 1 if `st_gen' is member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_GEN */
+
+/* Define to 1 if `st_rdev' is member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_RDEV 1
+
+/* Define to 1 if `tm_zone' is member of `struct tm'. */
+/* #undef HAVE_STRUCT_TM_TM_ZONE */
+
+/* Define to 1 if your `struct stat' has `st_blocks'. Deprecated, use
+   `HAVE_STRUCT_STAT_ST_BLOCKS' instead. */
+/* #undef HAVE_ST_BLOCKS */
+
+/* Define if you have the 'symlink' function. */
+#define HAVE_SYMLINK 1
+
+/* Define to 1 if you have the `sysconf' function. */
+/* #undef HAVE_SYSCONF */
+
+/* Define to 1 if you have the <sysexits.h> header file. */
+/* #undef HAVE_SYSEXITS_H */
+
+/* Define to 1 if you have the <sys/audioio.h> header file. */
+/* #undef HAVE_SYS_AUDIOIO_H */
+
+/* Define to 1 if you have the <sys/bsdtty.h> header file. */
+/* #undef HAVE_SYS_BSDTTY_H */
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+/* #undef HAVE_SYS_FILE_H */
+
+/* Define to 1 if you have the <sys/loadavg.h> header file. */
+/* #undef HAVE_SYS_LOADAVG_H */
+
+/* Define to 1 if you have the <sys/lock.h> header file. */
+/* #undef HAVE_SYS_LOCK_H */
+
+/* Define to 1 if you have the <sys/mkdev.h> header file. */
+/* #undef HAVE_SYS_MKDEV_H */
+
+/* Define to 1 if you have the <sys/modem.h> header file. */
+/* #undef HAVE_SYS_MODEM_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+/* #undef HAVE_SYS_POLL_H */
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+/* #undef HAVE_SYS_RESOURCE_H */
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+/* #undef HAVE_SYS_SOCKET_H */
+
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+/* #undef HAVE_SYS_STATVFS_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+/* #undef HAVE_SYS_TIMES_H */
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+/* #undef HAVE_SYS_UN_H */
+
+/* Define to 1 if you have the <sys/utsname.h> header file. */
+/* #undef HAVE_SYS_UTSNAME_H */
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the `tcgetpgrp' function. */
+/* #undef HAVE_TCGETPGRP */
+
+/* Define to 1 if you have the `tcsetpgrp' function. */
+/* #undef HAVE_TCSETPGRP */
+
+/* Define to 1 if you have the `tempnam' function. */
+/* #undef HAVE_TEMPNAM */
+
+/* Define to 1 if you have the <termios.h> header file. */
+#define HAVE_TERMIOS_H 1
+
+/* Define to 1 if you have the <term.h> header file. */
+/* #undef HAVE_TERM_H */
+
+/* Define to 1 if you have the <thread.h> header file. */
+/* #undef HAVE_THREAD_H */
+
+/* Define to 1 if you have the `timegm' function. */
+/* #undef HAVE_TIMEGM */
+
+/* Define to 1 if you have the `times' function. */
+/* #undef HAVE_TIMES */
+
+/* Define to 1 if you have the `tmpfile' function. */
+/* #undef HAVE_TMPFILE */
+
+/* Define to 1 if you have the `tmpnam' function. */
+/* #undef HAVE_TMPNAM */
+
+/* Define to 1 if you have the `tmpnam_r' function. */
+/* #undef HAVE_TMPNAM_R */
+
+/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use
+   `HAVE_STRUCT_TM_TM_ZONE' instead. */
+/* #undef HAVE_TM_ZONE */
+
+/* Define to 1 if you have the `truncate' function. */
+/* #undef HAVE_TRUNCATE */
+
+/* Define to 1 if you don't have `tm_zone' but do have the external array
+   `tzname'. */
+/* #undef HAVE_TZNAME */
+
+/* Define this if you have tcl and TCL_UTF_MAX==6 */
+/* #undef HAVE_UCS4_TCL */
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the `uname' function. */
+/* #undef HAVE_UNAME */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+/* #undef HAVE_UNSETENV */
+
+/* Define if you have a useable wchar_t type defined in wchar.h; useable means
+   wchar_t must be an unsigned type with at least 16 bits. (see
+   Include/unicodeobject.h). */
+/* #undef HAVE_USABLE_WCHAR_T */
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+#define HAVE_UTIME_H 1
+
+/* Define to 1 if you have the `wait3' function. */
+/* #undef HAVE_WAIT3 */
+
+/* Define to 1 if you have the `wait4' function. */
+/* #undef HAVE_WAIT4 */
+
+/* Define to 1 if you have the `waitpid' function. */
+#define HAVE_WAITPID 1
+
+/* Define if the compiler provides a wchar.h header file. */
+/* #undef HAVE_WCHAR_H */
+
+/* Define to 1 if you have the `wcscoll' function. */
+/* #undef HAVE_WCSCOLL */
+
+/* Define if tzset() actually switches the local timezone in a meaningful way.
+   */
+/* #undef HAVE_WORKING_TZSET */
+
+/* Define if the zlib library has inflateCopy */
+#define HAVE_ZLIB_COPY 1
+
+/* Define to 1 if you have the `_getpty' function. */
+/* #undef HAVE__GETPTY */
+
+/* Define if you are using Mach cthreads directly under /include */
+/* #undef HURD_C_THREADS */
+
+/* Define if you are using Mach cthreads under mach / */
+/* #undef MACH_C_THREADS */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
+   */
+/* #undef MAJOR_IN_MKDEV */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in
+   <sysmacros.h>. */
+/* #undef MAJOR_IN_SYSMACROS */
+
+/* Define if mvwdelch in curses.h is an expression. */
+/* #undef MVWDELCH_IS_EXPRESSION */
+
+/* Define to the address where bug reports for this package should be sent. */
+/* #undef PACKAGE_BUGREPORT */
+
+/* Define to the full name of this package. */
+/* #undef PACKAGE_NAME */
+
+/* Define to the full name and version of this package. */
+/* #undef PACKAGE_STRING */
+
+/* Define to the one symbol short name of this package. */
+/* #undef PACKAGE_TARNAME */
+
+/* Define to the version of this package. */
+/* #undef PACKAGE_VERSION */
+
+/* Defined if PTHREAD_SCOPE_SYSTEM supported. */
+/* #undef PTHREAD_SYSTEM_SCHED_SUPPORTED */
+
+/* Define to printf format modifier for Py_ssize_t */
+#define PY_FORMAT_SIZE_T "z"
+
+/* Define as the integral type used for Unicode representation. */
+#define PY_UNICODE_TYPE unsigned short
+
+/* Define if you want to build an interpreter with many run-time checks. */
+/* #undef Py_DEBUG */
+
+/* Defined if Python is built as a shared library. */
+/* #undef Py_ENABLE_SHARED */
+
+/* Define as the size of the unicode type. */
+#define Py_UNICODE_SIZE 2
+
+/* Define if you want to have a Unicode type. */
+#define Py_USING_UNICODE 1
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define if setpgrp() must be called as setpgrp(0, 0). */
+/* #undef SETPGRP_HAVE_ARG */
+
+/* Define this to be extension of shared libraries (including the dot!). */
+#define SHLIB_EXT ".so"
+
+/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */
+/* #undef SIGNED_RIGHT_SHIFT_ZERO_FILLS */
+
+/* The size of `double', as computed by sizeof. */
+#define SIZEOF_DOUBLE 8
+
+/* The size of `float', as computed by sizeof. */
+#define SIZEOF_FLOAT 4
+
+/* The size of `fpos_t', as computed by sizeof. */
+/* #undef SIZEOF_FPOS_T */
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The number of bytes in an off_t. */
+#define SIZEOF_OFF_T 8
+
+/* The number of bytes in a pthread_t. */
+/* #undef SIZEOF_PTHREAD_T */
+
+/* The size of `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* The size of `size_t', as computed by sizeof. */
+#define SIZEOF_SIZE_T 4
+
+/* The number of bytes in a time_t. */
+#define SIZEOF_TIME_T 8
+
+/* The size of `uintptr_t', as computed by sizeof. */
+#define SIZEOF_UINTPTR_T 4
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 4
+
+/* The size of `wchar_t', as computed by sizeof. */
+/* #undef SIZEOF_WCHAR_T */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if you can safely include both <sys/select.h> and <sys/time.h>
+   (which you can't on SCO ODT 3.0). */
+#define SYS_SELECT_WITH_SYS_TIME 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Define if you want to use MacPython modules on MacOSX in unix-Python. */
+/* #undef USE_TOOLBOX_OBJECT_GLUE */
+
+/* Define if a va_list is an array of some kind */
+/* #undef VA_LIST_IS_ARRAY */
+
+/* Define if you want SIGFPE handled (see Include/pyfpe.h). */
+/* #undef WANT_SIGFPE_HANDLER */
+
+/* Define if you want wctype.h functions to be used instead of the one
+   supplied by Python itself. (see Include/unicodectype.h). */
+/* #undef WANT_WCTYPE_FUNCTIONS */
+
+/* Define if WINDOW in curses.h offers a field _flags. */
+/* #undef WINDOW_HAS_FLAGS */
+
+/* Define if you want documentation strings in extension modules */
+#define WITH_DOC_STRINGS 1
+
+/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic
+   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).
+   Dyld is necessary to support frameworks. */
+/* #undef WITH_DYLD */
+
+/* Define to 1 if libintl is needed for locale functions. */
+/* #undef WITH_LIBINTL */
+
+/* Define if you want to produce an OpenStep/Rhapsody framework (shared
+   library plus accessory files). */
+/* #undef WITH_NEXT_FRAMEWORK */
+
+/* Define if you want to compile in Python-specific mallocs */
+#define WITH_PYMALLOC 1
+
+/* Define if you want to compile in rudimentary thread support */
+/* #undef WITH_THREAD */
+
+/* Define to profile with the Pentium timestamp counter */
+/* #undef WITH_TSC */
+
+
+ /* Define to 1 if your processor stores words with the most significant byte
+    first (like Motorola and SPARC, unlike Intel and VAX).
+
+    The block below does compile-time checking for endianness on platforms
+    that use GCC and therefore allows compiling fat binaries on OSX by using
+    '-arch ppc -arch i386' as the compile flags. The phrasing was choosen
+    such that the configure-result is used on systems that don't use GCC.
+  */
+#ifdef __BIG_ENDIAN__
+#define WORDS_BIGENDIAN 1
+#else
+#ifndef __LITTLE_ENDIAN__
+/* #undef WORDS_BIGENDIAN */
+#endif
+#endif
+
+/* Define to 1 if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* # undef _ALL_SOURCE */
+#endif
+
+/* Define on OpenBSD to activate all library features */
+/* #undef _BSD_SOURCE */
+
+/* Define on Irix to enable u_int */
+#define _BSD_TYPES 1
+
+/* This must be set to 64 on some systems to enable large file support. */
+#define _FILE_OFFSET_BITS 64
+
+/* Define on Linux to activate all library features */
+#define _GNU_SOURCE 1
+
+/* This must be defined on some systems to enable large file support. */
+#define _LARGEFILE_SOURCE 1
+
+/* Define on NetBSD to activate all library features */
+#define _NETBSD_SOURCE 1
+
+/* Define _OSF_SOURCE to get the makedev macro. */
+/* #undef _OSF_SOURCE */
+
+/* Define to activate features from IEEE Stds 1003.1-2001 */
+#define _POSIX_C_SOURCE 200112L
+
+/* Define if you have POSIX threads, and your system does not define that. */
+/* #undef _POSIX_THREADS */
+
+/* Define to force use of thread-safe errno, h_errno, and other functions */
+/* #undef _REENTRANT */
+
+/* Define to the level of X/Open that your system supports */
+#define _XOPEN_SOURCE 600
+
+/* Define to activate Unix95-and-earlier features */
+#define _XOPEN_SOURCE_EXTENDED 1
+
+/* Define on FreeBSD to activate all library features */
+#define __BSD_VISIBLE 1
+
+/* Define to 1 if type `char' is unsigned and you are not using gcc.  */
+#ifndef __CHAR_UNSIGNED__
+/* # undef __CHAR_UNSIGNED__ */
+#endif
+
+/* Defined on Solaris to see additional function prototypes. */
+/* #undef __EXTENSIONS__ */
+
+/* Define to 'long' if <time.h> doesn't define. */
+/* #undef clock_t */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to empty if the keyword does not work. */
+/* #undef signed */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int' if <sys/socket.h> does not define. */
+/* #undef socklen_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Define to empty if the keyword does not work. */
+/* #undef volatile */
+
+
+/* Define the macros needed if on a UnixWare 7.x system. */
+#if defined(__USLC__) && defined(__SCO_VERSION__)
+#define STRICT_SYSV_CURSES /* Don't use ncurses extensions */
+#endif
+
+#endif /*Py_PYCONFIG_H*/
